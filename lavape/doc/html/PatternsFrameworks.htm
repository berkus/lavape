<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Patterns/frameworks</title>
  <meta http-equiv="Content-Style-Type" content="text/css"/>
  <link rel="STYLESHEET" type="text/css" href="LavaStyles.css" />
  <style type="text/css" xml:space="preserve">
/*<![CDATA[*/
  p.c7 {font-weight: bold; text-align: left}
  p.c6 {font-weight: bold}
  p.c5 {text-align: justify}
  b.c4 {font-style: italic; color: Red}
  i.c3 {font-weight: bold; color: Red}
  h3.c2 {text-align: left}
  h2.c1 {text-align: center}
  /*]]>*/
  </style>
  <style type="text/css" xml:space="preserve">
/*<![CDATA[*/
  p.c1 {font-weight: bold}
  /*]]>*/
      .style1
      {
          color: #FF0000;
          font-style: italic;
          font-weight: bold;
      }
  </style>
</head>

<body>
  <h2 class="c1">G<b>enericity and Virtual Types (VTs),<br />
  design patterns, and frameworks</b></h2>

  <h3 class="c2">1. Introduction</h3>

  <p><a target="_blank" href="http://hillside.net/patterns/">Design patterns</a> <a href="TypeSafety.htm#GOF">[8]</a> <a target="_blank" href="http://c2.com/cgi/wiki?CategoryPattern">*)</a> <a target="_blank" href="http://www.cmcrossroads.com/bradapp/docs/patterns-intro.html">**)</a> and frameworks are frequently represented by groups of cooperating, interdependent classes that reference each other and that have to be specialized/derived <b>collectively</b> in a <b>consistent</b> way in order to be used in actual applications. The term &quot;framework&quot; refers to the overall, top-level structure of entire applications while &quot;design patterns&quot; may also deal with groups of lower-level interdependent &quot;generic utility classes&quot; that may be specialized for concrete usage. Although the definition of design patterns would be given in natural language, perhaps enhanced by sketchy sample programs in a concrete programming language, it would be highly desirable to provide immediately reusable versions of design patterns in concrete programming languages like <i class="c3">Lava</i>.</p>

  <p>The widespread programming languages, however, do not provide proper expressive means for implementing concrete incarnations of design patterns. Parameterized classes as the <b>&quot;templates&quot;</b> of <b class="c4">C++</b> or the <b>&quot;generic classes&quot;</b> of <b class="c4">Eiffel</b> do not meet the requirements: They can be viewed as special macros or as type generation constructs having three serious drawbacks:</p>

  <ol>
    <li>They do not properly describe parameterized <b>groups</b> of interdependent classes but mainly <b>single</b> parameterized classes.</li>

    <li>They do not provide a derivation mechanism that allows you to derive specialized classes from those parameterized templates or generic classes.</li>

    <li>The older implementation techniques (<span class="style1">C++</span>) entail code replication rather than code reuse and thus are prone to blow up the program sizes as well as the time required for compilation/linking.</li>
  </ol>

  <p>For the design of <b class="c4">Lava</b> we have drawn the following conclusions from this situation and from the fact that we have a <a href="Packages.htm#packages">package</a> notion in <b class="c4">Lava</b> anyway that allows us to form groups of related classes or other declarations:</p>

  <ol>
    <li><b class="c4">Lava</b> introduces patterns as packages or classes with named type parameters (<b>&quot;pattern parameters&quot;</b> or <b><a id="VT"></a>&quot;virtual types&quot;</b>, short: <b>VT</b>). Packages/classes with VTs are called <b>&quot;patterns&quot;</b> since they are used to provide concrete implementations of design patterns in <i class="c3">Lava</i>.</li>

    <li>The value of a VT may designate a <b class="c4">Lava</b> class or another VT defined on this same level. A VT of a class may in particular designate its containing class and serve as a <b class="c4">Lava</b> substitute for the ThisType or MyType of other VT proposals.</li>

    <li><a id="derivedPattern"></a>A virtual type may also be <b>&quot;abstract&quot;</b>. Then its value is &quot;void&quot;; a non-void value may be assigned when overriding the abstract VT in a <b>derived pattern</b>.</li>

    <li>A VT <i>v</i> of a package/class P1 may be <b>overridden</b> in a <b>derived package/class</b> P2 by assigning a new value <i>nv</i> to it, which has to be derived from the value of <i>v</i> in the base package/class (except if <i>v</i> is abstract there). To override v you select it in the <a href="OverrideView.htm">override view</a> of P2 and proceed as described in the pertinent section.</li>

    <li>If a class <i>A</i> is declared within a pattern <i>P</i> then it can be extended only within <i>P</i> or within patterns derived from P.<br />
    <br />
    (This condition could possibly be weakened, but that would complicate the implementation as well as the rules that have to be obeyed by the programmers. The present wording just reflects the fact that the values of the VTs that may be referenced in A or its extension are defined only within P or patterns derived from P.)</li>

    <li>Classes from more derived patterns cannot be used in base patterns.</li>

    <li>VTs may be used to declare the types of local and member variables as well as of function arguments : Their actual, concrete types depend on the respective <b>&quot;pattern context&quot;</b> (see 10. below) then <b>(</b><a id="covariant"></a><b>&quot;covariant specialization&quot;)</b>.</li>

    <li><a id="VTvisibility"></a>The <b>&quot;visibility&quot; of VT</b>s is restricted in the following way: They are visible in the containing package or class where they are introduced. If they are visible in a class <i>A</i> then also in every nested declaration and in every implementation of <i>A</i>. If they are visible in a class or package <i>P</i> then also in every class/package derived from <i>P</i> unless they are overridden there. Classes declared in a pattern <i>P&#39;</i> that is derived from <i>P</i> cannot be referenced in <i>P</i>.</li>

    <li><a id="VTandNonVT"></a>If a class <i>A</i> is the value of a virtual type <i>V</i> then <i>A</i> cannot be referenced directly at any place where <i>V</i> is visible. It can only be referenced indirectly by references to <i>V</i> in these places. If A1 is derived from A within the same pattern, then A1 cannot be referenced directly, either. (A motivation of this rule is given in our <a href="IsSelfVirtualSample.htm">IsSelfVirtual sample</a>.)</li>

    <li><a id="patternContext"></a><b class="c4">Lava</b> restricts the ways in which pattern declarations may be nested: There may be only <b>two nested layers</b> of packages or classes containing virtual types. (The VT implementation costs would be considerably higher if nesting of VT layers to any depth would be allowed.) The lower layer is called the <b>&quot;inner pattern context&quot;</b>, the higher one the <b>&quot;outer pattern context&quot;</b> of the declarations belonging to or nested in the lower layer. Generally, the term &quot;pattern context of a declaration&quot; designates the <i>combination</i> of the inner and outer pattern context.</li>

    <li><b class="c4">Lava</b> supports <b>multiple inheritance</b> not only on the class level but also on the package level: A package may be derived from one or several other packages. Non-overridden virtual types from immediate or indirect base patterns are inherited and visible also in the derived pattern.</li>

    <li>If a pattern <i>P1</i> references a type <i>T2</i> that is the value of a virtual type of a separate pattern <i>P2</i> and a third pattern <i>P3</i> is derived from <i>P1</i> and <i>P2</i>, then the reference to <i>T2</i> is still treated as an &quot;external&quot; rather than as a virtual type reference (although <i>T2</i> belongs to the context of common derived pattern <i>P3</i> now).</li>

    <li><b class="c4">Lava</b> maintains the classical view of parameterized types (like C++ templates) insofar as it considers two instantiations of the same type in different pattern contexts to be incompatible.</li>
  </ol>

  <p>The currently valid value of a pattern parameter or <b>&quot;virtual type (VT)&quot;</b> is taken at run time from a <b>&quot;virtual type table (VTT)&quot;</b> similar to the usual <b>&quot;virtual function table (VFT)&quot;</b> of object-oriented programming systems. As usual, <b class="c4">Lava</b> provides for every <b class="c4">Lava</b> object a pointer to its associated VFT, but additionally also a pointer to an associated VTT. Like the VFT, the proper VTT is determined on object creation, roughly spoken as the &quot;pattern context&quot; of its implementation, and this is in turn the pattern context of the class that the latter implements.</p>

  <p>Generally, we use the term <b>type</b> for a <i>concrete class</i> or a <i>virtual type / pattern parameter</i> in the sense explained above. (Both may be referenced as types of variables in <i class="c3">Lava</i> programs.)</p>

  <p>A type is called a <b><a id="multiform"></a>multiform type</b> if it is either a virtual type or a class that is declared within a pattern. The meaning of a multiform type may depend on the pattern context where it is used. We use &quot;uniform&quot; as a synonym for &quot;non-multiform&quot;.</p>

  <p>Virtual types may be referenced anywhere (on any nesting level) within their &quot;owner&quot; package or class, but also in implementations of classes belonging to that scope. (These implementations may be located even outside this scope.)</p>

  <p>Summary: A <i class="c3">Lava</i> pattern is just a quite normal package or class declaration, having virtual types.</p>

  <h3>2. Representation and specialization of patterns in <b class="c4">LavaPE</b></h3>

  <p>In the <a href="EditTree.htm"><b class="c4">Lava</b> declaration view</a> a pattern is just a quite normal <a href="Packages.htm">package</a> or <a href="SepItfImpl.htm">class</a> declaration, having virtual types (VT). <a id="VTvalue"></a> A virtual type vt has a name and a value VAL(vt). The value may be a class (having the name of the virtual type) or the name of another VT. (The term <a id="bound"></a>&quot;bound&quot; is also used in the literature for the value of a VT.)</p>

  <p class="c5">A virtual type may also be &quot;abstract&quot;. Then its value is &quot;empty&quot;; a non-empty value may be assigned when overriding the abstract VT in a derived pattern.</p>

  <p class="c5">A VT is called &quot;final&quot; if its value is a class. This class cannot be referenced then as a normal class within the containing pattern; its name rather denotes the VT whose value it is. Outside the pattern, it denotes just the class.</p>

  <p class="c5">Moreover, classes (and virtual types anyway) of a derived pattern P cannot be referenced in base patterns of P.</p>

  <p>A VT has a <i>name</i> and a <i>value</i>. The value may be (the name of) a class or of another VT. A virtual type may also be &quot;abstract&quot;. Then its value is &quot;empty&quot;; a non-empty value may be assigned when overriding the abstract VT in a derived pattern.</p>

  <p>Generally, package and class declarations may be <a id="nesting"></a> <b>nested to any depth</b> in <b class="c4">Lava</b> (but class declarations cannot contain nested package declarations). For packages and classes with virtual types the above-mentioned <a href="#patternContext">restrictions</a> apply, however.</p>

  <p>Specialization of patterns makes use of the same <a href="OverrideView.htm"><i class="c3">Lava</i> override view</a> that is also used for quite normal class derivation.</p>

  <h3>3. Static type-safety of <b><i>Lava</i>, related work</b></h3>

  <p>A <a href="TypeSafety.htm">special section</a> of this documentation has been dedicated to the static type-safety of <i class="c3">Lava</i>. The relation of our approach to other notions of virtual types is discussed <a href="TypeSafety.htm#relatedWork">here</a>. An outline of the <a href="TypeSafety.htm#proof">proof</a> of the static type-safety of <b class="c4">Lava</b> can be found at the same place.</p>

  <p class="c1">See also:</p>

  <p class="c6"><a href="TypeCasts.htm">Patterns and type casts</a></p>

  <p class="c7"><a href="PatternSamples.htm">Pattern samples</a></p>
</body>
</html>
