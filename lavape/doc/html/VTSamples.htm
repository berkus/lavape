<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<meta http-equiv="Content-Language" content="en-us">
<TITLE>Non-substitutable virtual type samples</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<META content="Klaus D. Günther" name=Author>
<META content="Microsoft FrontPage 5.0" name=GENERATOR>
<meta name="ProgId" content="FrontPage.Editor.Document">
<LINK href="LavaStyles.css" 
type=text/css rel=STYLESHEET></HEAD>
<BODY>
<H2 align=center>Basic virtual type samples </H2>
<H3>Sample files</H3>
<p>Please open <b>ChoralSociety.lava</b> in
<font color="#FF0000"><b><i>LavaPE</i></b></font>.</p>
<P>Das gleiche Beispiel auf Deutsch&nbsp;(the same sample in German):&nbsp;</P>
<P>Please open <b>Gesangverein.lava</b> in
<font color="#FF0000"><b><i>LavaPE</i></b></font>.</P>
<P>Please open <b>ModelView.lava</b> in
<font color="#FF0000"><b><i>LavaPE</i></b></font>.</P>
<P>Please open <b>QueueOfPoint.lava</b> in
<font color="#FF0000"><b><i>LavaPE</i></b></font>.</P>
<P>Please open <b>Visitor.lava</b> in
<font color="#FF0000"><b><i>LavaPE</i></b></font>.</P>
<H3>Topic </H3>
<P>Interfaces and packages with type parameters ("<A 
href="PatternsFrameworks.htm#VT">virtual types</A>"), <A 
href="PatternsFrameworks.htm#covariant">covariant specialization</A>. </P>
<H3>Overview</H3>
<P><STRONG>ChoralSociety:</STRONG></P>
<P>The ChoralSociety sample provides a package <EM>S</EM> ("Society") with two 
virtual types <EM>society</EM> and <EM>member</EM>. In <EM>S</EM> the value of 
<EM>society</EM> is the type <EM>Society</EM>, the value of <EM>member</EM> is 
<EM>Member</EM>. A second package <EM>CS</EM> ("ChoralSociety") is derived from 
<EM>S</EM> by specializing <EM>society</EM> to become <EM>ChoralSociety</EM> (in 
turn derived fro <EM>Society</EM>) and <EM>member</EM> to become <EM>Singer</EM> 
(derived from <EM>Member). </EM>As a consequence, the <EM>MemberList</EM> 
becomes a list of <EM>Singer</EM>s in <EM>CS</EM> automatically, and the 
chairman is also a <EM>Singer</EM> in <EM>CS</EM> rather than just a 
<EM>Member</EM>.</P>
<P><STRONG>Gesangverein:</STRONG></P>
<P>Das Gesangvereins-Beispiel enthält ein Package&nbsp;<EM>V</EM> ("Verein") mit 
zwei virtuellen Typen <EM>verein</EM> und <EM>mitglied</EM>. In&nbsp;<EM>V</EM> 
ist der Wert von&nbsp;<EM>verein </EM>der Typ <EM>Verein</EM>, der Wert von 
<EM>mitglied</EM> ist <EM>Mitglied.</EM> Aus <EM>V</EM> wird ein weiteres 
Package <EM>GV</EM> ("Gesangverein") abgeleitet, und zwar dadurch, dass 
<EM>verein</EM> zu <EM>Gesangverein</EM> (aus <EM>Verein</EM> abgeleitet) und 
<EM>mitglied</EM> zu <EM>Saenger</EM> (aus <EM>Mitglied</EM> abgeleitet) 
spezialisiert werden.&nbsp;Infolgedessen wird automatisch aus der 
<EM>Mitgliederliste</EM> des <EM>Verein</EM>s eine Liste von <EM>Saenger</EM>n 
im <EM>Gesangverein</EM>, und der Vorsitzende des Gesangvereins ist ebenfalls 
ein <EM>Saenger</EM> und nicht nur ein <EM>Mitglied</EM>. </P>
<P><STRONG>ModelView:</STRONG></P>
<P>The ModelView sample (based on the well-known subject/observer pattern) 
reconstructs the corresponding sample from <A href="TypeSafety.htm#TT">[16]</A>. 
It provides a package <EM>ModelViewFW</EM> ("model/view framework") with two 
type parameters "model" and "view".&nbsp; "ModelViewFW" contains two mutually 
recursive types "Model" and "View". "Model" contains a member vList which is a 
<I>homogeneous</I> "ViewList" all of whose elements have the same virtual type 
setElem=~&lt;view&gt;. (The tilde "~" marks variable <A 
href="TwoObjectCategories.htm">state objects</A> in <B><I><FONT 
color=#ff0000>Lava</FONT></I></B>.) </P>
<P>Package "DrawFW" shows how the (rudimentary) framework "ModelViewFW" could be 
specialized by overriding its virtual types (= type parameters) "model" and 
"view". </P>
<P>See our <A href="SubstitutableSamples.htm">ModelManyViews</A> sample for 
another variant of Model/View that provides an <I>inhomogeneous</I> "ViewList" 
containing <I>different</I> types of views (on the basis of "<A 
href="TypeSafety.htm#substitutableType">substitutable types</A>"). </P>
<P><B>QueueOfPoint:</B></P>
<P>The QueueOfPoint sample corresponds to a similar sample in <A 
href="TypeSafety.htm#TT">[16]</A>, too. Compared to <A 
href="TypeSafety.htm#TT">[16]</A>, it shows again the advantage of making 
virtual types non-substitutable by default: We need not view the virtual type 
"elemType" as a special, type-valued <I>member variable</I> of "Queue" objects 
but we can introduce virtual types in a more static way as <I>type</I> 
<I>parameters</I> of interfaces and packages. </P>
<P><b>Visitor:</b></P>
<P>The Visitor sample illustrates a special case of the well-known 
&quot;Visitor&quot; pattern of <a href="TypeSafety.htm#GOF">[8]</a> and also a special 
case of <a href="RepetComputSamples.htm">indirect tree recursion</a>.</P>
<H3>Where to look and what to do</H3>
<P><B>ModelView:<br>
</B>
<br>
Note in particular the "<A href="PatternsFrameworks.htm#covariant">covariant 
specialization</A>" of the only input parameter of function <I>registerView</I> 
of interface <I>Model</I>.&nbsp; </P>
<P>Note how this is exploited in the exec of the initiator <I>ModelViewDemo</I> 
to pass a view object of the derived type <I>DrawFW::View</I> to this 
function.&nbsp; </P>
<P>Note that <I>DrawFW::View </I>is <B>not</B> compatible in the traditional 
sense (of <A href="TypeSafety.htm#c-derived">c-derivation</A>) to 
ModelViewFW::View, since it contains member variables (<I>myModel</I>) and 
function parameters (m of initializer <I>ini</I>) that are of a more derived 
type in pattern <I>DrawFW</I> than in <I>ModelViewFW</I> (as a consequence of 
covariant specialization of the VT <I>&lt;model&gt;</I>).&nbsp; </P>
<P><B><A name=queueOfPoint></A>QueueOfPoint:<br>
</B>
<br>
Note the two versions of interface <I>X</I>: One belongs to pattern 
<I>Queue</I> (an interface having a VT <I>elemType</I>), the other is declared 
outside <I>Queue</I>. Both have a member function <I>f</I> with almost identical 
implementations. Look at these:</P>
<P>The difference between the implementations of the two versions of <I>f </I>is 
that one of them belongs to pattern <I>Queue,</I> and one doesn't. The former 
<B>has to</B> use the virtual type <I>&lt;Queue::elemType&gt;</I> of 
<I>Queue</I> to declare the local variable <I>p</I>, the latter <B>cannot</B> 
use this but <B>must</B> use the concrete interface <I>Point</I> to declare 
<I>p</I>. The reasons are:</P>
<OL>
  <LI>If an interface <I>A</I> is the value of a virtual type <I>V</I> then 
  <I>A</I> cannot be referenced directly at any place where <I>V</I> is visible. 
  It can only be referenced indirectly by references to <I>V</I> in these 
  places. If A1 is derived from A within the same pattern, then A1 cannot be 
  referenced directly, either. 
  <LI>From outside a pattern the VTs of that pattern cannot be referenced (they 
  are invisible to the "outside world"). </LI></OL>
<P>The first rule corresponds to <A 
href="PatternsFrameworks.htm#VTandNonVT">rule 9</A> in our <FONT 
color=#ff0000><I><B>Lava</B></I></FONT> genericity section. Its motivation is 
explained in our <A href="IsSelfVirtualSample.htm">IsSelfVirtual sample</A>.</P>
<P>The reason for the validity of the second rule is simple: The value of a VT 
(= type parameter) is determined by the respective <A 
href="PatternsFrameworks.htm#patternContext">pattern context</A>. So if you are 
outside a pattern P and outside of any pattern that is derived from P, the 
values of P's VTs at the actual place of reference are just undefined.</P>
<P><b><a name="visitor"></a>VirtualVisitor:<br>
</b>
<br>
The <i>Visitor</i> pattern defines an abstract virtual type <i>R</i> for the 
result of the visitor's tree evaluation function <i>evaluate</i>. The way how 
the visitor walks through the tree is described by this <i>evaluate</i> method 
and doesn't depend on <i>R</i>, while the treatment of the individual tree nodes 
depends on <i>R</i> and is implemented by the overridden methods <i>evalLeaf</i> 
and <i>evalNode</i> of <i>StringVisitor</i> and <i>IntVisitor</i>. The initiator
<i>VisitorDemo</i> shows how a sample tree is constructed and how this same tree 
is evaluated twice: once by the <i>StringVisitor</i> and once by the <i>
IntVisitor</i>.</P>
<P>Please notice the comments in the VisitorDemo initiator.</P>
<P><B>See also</B> our <A 
href="CallbackSample.htm"><B>CallbackSample</B></A></P></BODY></HTML>