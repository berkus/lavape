<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta http-equiv="Content-Language" content="en-us"><title>Member variable property sheet</title>

<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta content="Klaus D. Günther" name="Author">
<meta content="Microsoft FrontPage 5.0" name="GENERATOR">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link href="../LavaStyles.css" type="text/css" rel="STYLESHEET">
</head>
<body>
<h2 align="center">Member variable property sheet</h2>
<h3>Name</h3>
<p>The name of a function parameter may contain only letters,
digits, and "_". The first character must not be a digit.</p>
<h3>Enable renaming</h3>
<p>YYou may change the names of functions, member variables and
virtual types when you override them in a derived class or pattern (for
instance in order to resolve name collisions in cases of multiple
inheritance). They inherit the names of the base versions by default
(and their name is changed accordingly if the inherited base name is
changed). Check this check-box if you would like to assign a different
name (which will not be changed then if the base name is changed).</p>
<h3>Substitutable type</h3>
<p>Indicates whether the type of this member variable shall be <a href="../TypeSafety.htm#substitutableType">substitutable</a>,
i.e., whether the type of a corresponding actual parameter may also be <a href="../TypeSafety.htm#p-derived">p-derived</a>
(rather than <a href="../TypeSafety.htm#c-derived">c-derived</a>)
from this formal parameter type. (Cf. the <i><a href="../PatternSamples.htm">ModelManyViews</a></i>
and <i><a href="../PatternSamples.htm">CarMeeting</a></i>
samples.)</p>
<h3>Remove overrides</h3>
<p>Transforms an overridden member variable into a non-overridden
one, as if it had been newly declared in the containing class.</p>
<h3>Select type of member variable</h3>
<p>The type of the member variable may be selected from the
combo-boxes "Basic types" and "Other types". "Basic types" lists all
classes whose declaration is contained in the basic include file
I&gt;std.lava. If you don't explicitly select a type for a new
member variable then its type will be <i>String</i>.</p>
<h3>Kind of reference</h3>
<p>This attribute enables us to distinguish <a href="../PointersRefCounts.htm#refTypes">three kinds of
references</a> to other objects: <i>Constituents</i>,
<i>acquaintances</i>, and <i>reverse</i> (back
or up) links. Constituents <i>belong</i> to the current
object, acquaintances are<i> pointers to independent objects</i>,
and reverse links are <i>auxiliary</i> back or up pointers
that are required to facilitate automatic storage management by
reference counts.</p>
<h3>Category</h3>
<p>Check this if the member shall be treated as a variable <a href="../TwoObjectCategories.htm">state object</a> ;
otherwise it will be treated as an immutable <a href="../TwoObjectCategories.htm">value object</a>,
i.e., its direct and nested <a href="../PointersRefCounts.htm#refTypes"> constituents</a>
cannot be modified after the object has been completely <a href="../ObjectLifeCycle.htm#creation">created/initialized</a>.</p>
<h3>Protected</h3>
<p>A A href="../ProtectedFriend.htm"&gt;protected member
variable can be accessed only by functions contained in the
implementation of the present or a derived class.</p>
<h3>Read-only</h3>
<p>A read-only member variable <i>xy</i> of some
object can be assigned a value only "from inside the object" via the
path <i>self.xy</i>,, i.e., from within functions
belonging to the current class or its implementation. It is
write-protected against access "from outside".</p>
<h3>Abstract</h3>
<p>This attribute is enabled only if the member variable is
accessed via set/get functions (see next paragraph). It allows you to
defer the implementation of the set/get functions to a derived class:
So actually the set/get functions are abstract.</p>
<h3>Access via set/get functions</h3>
<p>If a member variable <i>xy</i> has this property
then <a href="../Unsolved.htm#setGetFunctions">set/get
functions</a> are generated for it in the implementation of the
containing class. Every read or write access to the variable is
redirected implicitly through these get/set functions. Only these
set/get functions themselves may directly access the variable. In this
way you can supervise every access attempt to the variable and, by
properly modifying the default set/get functions, achieve additional
side effects or perform access permission checks.</p>
<h3><a name="consumable"></a>Consumable</h3>
<p><i>Consumable</i> member variables are
used for <a href="../Transactions.htm#producerConsumer">producer/consumer
synchronization</a> in <i> <b><font color="#ff0000">Lava </font></b></i>(not
yet implemented).</p>
<h3>Mode</h3>
<p>The mode of a member variable may be <a name="mandatory"></a><b>mandatory</b>
(default), <b>optional</b>, or <b>placeholder</b>.
If <i>optional</i>, the parameter may assume the special <i>null
value</i> <font color="#0000ff"><b>Ø</b></font>
("undefined"). <i>Placeholder</i> members cannot be
accessed at all. They are used in <a href="../EditForm.htm">forms</a>
to describe fields that are to be <i>filled in</i> only in
a later step by some other person, although they are <i>visible</i>
from the beginning.</p>
<p></p>
<p><i><b>See also</b></i></p>
<p align="left"><i><a href="../SepItfImpl.htm"><b><i><font color="#ff0000">Lava</font></i>
classes/interfaces/implementations</b></a></i></p>
<p><i><b><font color="#ff0000"><a href="../ObjectLifeCycle.htm"><i>
<font color="#ff0000">Lava</font></i></a></font><a href="../ObjectLifeCycle.htm"> variables</a></b></i></p>
</body></html>

