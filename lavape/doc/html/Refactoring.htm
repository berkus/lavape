<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Lava refactoring support</title>
  <meta http-equiv="Content-Style-Type" content="text/css"/>
  <link rel="STYLESHEET" type="text/css" href="LavaStyles.css" />
  <style type="text/css" xml:space="preserve">
/*<![CDATA[*/
  i.c3 {font-weight: bold; color: Red}
  b.c2 {font-style: italic; color: Red}
  h2.c1 {text-align: center}
  /*]]>*/
      .style1
      {
          color: #FF0000;
          font-style: italic;
      }
      .style2
      {
          color: #FF0000;
          font-style: italic;
          font-weight: bold;
      }
  </style>
</head>

<body>
  <h2 class="c1"><span class="style1">Lava</span> refactoring support</h2>

  <p><em>&quot;Refactoring&quot;</em> has become a buzzword in today&#39;s software engineering discussion, and refactoring support is of growing importance for IDE&#39;s (Integrated Development Environments) that claim to be up-to-date.</p>

  <p><em>&quot;Refactoring&quot;</em> means to change and improve the structure of a program without changing its behavior. See, for instance, the <a target="_blank" href="http://www.refactoring.com/">Refactoring Home Page</a> and the <a target="_blank" href="http://tech.groups.yahoo.com/group/refactoring/">Refactoring discussion group at Yahoo</a>. Several (mostly 
      <span class="style2">Java</span>) IDE&#39;s are available now that provide either integrated refactoring support or a separate &quot;Refactoring Browser&quot;</p>

  <p>In <strong class="c2">Lava</strong>, refactoring support is <em>built-in</em> from the beginning and <em>integrated</em> to the highest possible degree: It doesn&#39;t even appear as a <em>special</em> service but rather as a collection of parenthetical side effects of quite normal editing operations of the <em class="c3">Lava</em> structure editors:</p>

  <ol>
    <li><strong>Renaming</strong> of all kinds of <em class="c3">Lava</em> entities (classes, functions, variables etc.) uses the same entity-specific property sheets that are also used when you <em>declare a new entity</em> or when you <em>change any other property</em> of the entity. As a parenthetical side effect all references to this entity are changed correspondingly to show the new name of the entity. This is achieved by fetching the current name of the entity <em>from its declaration</em> at every point of reference; the declaration is found from a symbol table that is indexed by the <em>immutable numeric internal identifiers</em> of all symbols.</li>

    <li><strong><a id="featureMove"></a> Moving/copying features</strong> (= member variables and functions) forth and back between base classes and derived classes or between classes and corresponding implementations uses the quite normal drag-and-drop or cut/copy/paste operations that are <em>always</em> used in <em class="c3">Lava</em> for restructuring the <em class="c3">Lava</em> <a href="EditTree.htm">declaration tree</a>. Errors caused by refactoring operations are tolerated in cases where only the programmer knows how to circumvent or repair these in a meaningful way. (See also <a href="EditTree.htm#undoRedo">undo/redo support</a> for drag-and-drop operations.)</li>

    <li><strong>Moving/copying other <em>Lava</em> entities</strong> uses these same drag-and-drop or cut/copy/paste operations. The fully qualified names of moved/copied entities, which reflect the nesting of packages and classes, are changed automatically as a parenthetical side effect.</li>

    <li><strong>Changing</strong> the number and/or order of the <strong>formal parameters</strong> of a function entails corresponding <em>automatic changes</em> of the actual parameter lists <em>of all invocations</em> of this function.</li>

    <li>
      <strong>Introducing or removing accessor (&quot;setter/getter&quot;) functions</strong> for member variables of a class is supported mainly by three specific measures:

      <ul>
        <li>The <em>same</em> variable access syntax is used transparently for read/write access to member variables, no matter whether or not the access operation is based on setter/getter functions: Setter/getter functions are called only <em>implicitly</em> in any case. So the points of access to this variable need not be changed if setter/getter access is turned on or off.</li>

        <li>Default setter/getter functions are generated automatically in the implementation of the class to which the respective member variable belongs when setter/getter access is turned on.</li>

        <li>The <em class="c3">Lava</em> interpreter &quot;knows&quot; that <em>within</em> a setter/getter function access operations to the respective member variable must not <em>recursively invoke</em> the setter/getter functions but have to be performed <em>directly</em>.</li>
      </ul>
    </li>
  </ol>

  <h3>Other refactoring links</h3>

  <p><a target="_blank" href="http://c2.com/cgi/wiki?WikiPagesAboutRefactoring">http://c2.com/cgi/wiki?WikiPagesAboutRefactoring</a></p>

  <p><a target="_blank" href="http://www.wikiservice.at/dse/wiki.cgi?CodeRefactoring">http://www.wikiservice.at/dse/wiki.cgi?CodeRefactoring</a> (German)</p>

  <p><a target="_blank" href="http://www.wikiservice.at/dse/wiki.cgi?RefactoringBrowser">http://www.wikiservice.at/dse/wiki.cgi?RefactoringBrowser</a> (German)</p>
</body>
</html>
