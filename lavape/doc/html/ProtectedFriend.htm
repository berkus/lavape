<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Protected/friend</title>
  <meta http-equiv="Content-Style-Type" content="text/css"/>
  <link rel="STYLESHEET" type="text/css" href="LavaStyles.css" />
  <style type="text/css" xml:space="preserve">
/*<![CDATA[*/
  em.c3 {font-weight: bold; color: Red}
  h2.c2 {text-align: center}
  strong.c1 {font-style: italic; color: Red}
  /*]]>*/
  </style>
</head>

<body>
  <h2 class="c2">&quot;Private&quot; / &quot;protected&quot; / &quot;friend&quot; counterparts in <strong class="c1">Lava</strong></h2>

  <h3>Private / friend</h3>

  <p>The <strong class="c1">Lava</strong> counterpart of <strong>&quot;private&quot;</strong> features of <strong class="c1">C++</strong> or <strong class="c1">Java</strong> classes are the features contained in <strong class="c1">Lava</strong> implementations. All <strong class="c1">Lava</strong> implementations are completely <strong>opaque</strong>. You cannot reference any <strong class="c1">Lava</strong> entity that is declared within a <strong class="c1">Lava</strong> implementation from outside that implementation.</p>

  <p>The analogous effect can be achieved also for <a href="Packages.htm#packages">packages</a> by declaring them to be <strong>opaque</strong>. Within an implementation or opaque package <em>IP</em> you can derive classes from &quot;outer&quot; base classes or declare new classes and <strong>share these within <em>IP</em> without making them visible to the outside world</strong>.</p>

  <p>Implementations of these new classes may be even located in separate <strong class="c1">Lava</strong> files but nevertheless have the same scope (visibility domain) as the classes they implement. The accessibility of <em>implementations</em> at run time is not restricted by these <em>&quot;opaque&quot;</em> specifiers. (Note that implementations need never be referenced expressly in <strong class="c1">Lava</strong>.)</p>

  <p>We leave it to the reader to compare this opaqueness notion of <strong class="c1">Lava</strong> with the capabilities inherent in the <strong class="c1">C++</strong> <strong>friend specification</strong> or the <strong>inner classes</strong> of <strong class="c1">Java</strong>.</p>

  <h3><a id="protected"></a>Protected</h3>

  <p>If a class <em>A</em> has a feature (= member variable or member function) <em>f</em> and interface <em>B</em> is derived from <em>A</em> then in some cases you would like to prevent users of <em>B</em> to directly access <em>f</em>. By analogy to the <strong class="c1">C++</strong> and <strong class="c1">Java</strong> &quot;protected&quot; specifier you can declare such a feature to be <strong>protected</strong> in the associated variable or function property sheet of <strong class="c1">LavaPE</strong> to make <em>f</em> invisible to the clients of <em>B</em> while remaining visible to <em>B</em> and its implementation.</p>

  <h3><a id="staticCalls"></a>Restrictions concerning static function calls</h3>

  <p>To call a function statically means that you circumvent the usual virtual function call (&quot;late binding&quot;) mechanism but you specify precisely which version of the function from which interface shall be called. If <em>f</em> is a member <em>f</em>unction of A then <em>f</em> can be 
      <strong>called statically</strong> only from derived classes in <strong class="c1">Lava</strong>, i.e., from functions that are declared in a derived interface <em>B</em> of <em>A</em> or in the implementation thereof. So if functions are declared in <em>A</em> and overridden in <em>B</em> then clients of <em>B</em> are forced to use the overridden version; they are not allowed to statically call the base version.</p>
</body>
</html>
