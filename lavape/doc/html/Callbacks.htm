<!DOCTYPE HTML PUBLIC "-//SoftQuad//DTD HoTMetaL PRO 4.0::19971010::extensions to HTML 4.0//EN"
 "hmpro4.dtd">

<HTML>
  
  <HEAD>
    <meta http-equiv="Content-Language" content="en-us">
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
    <META NAME="GENERATOR" CONTENT="Microsoft FrontPage 5.0">
    <meta name="ProgId" content="FrontPage.Editor.Document">
    <TITLE>Callbacks</TITLE>
    <LINK REL="STYLESHEET" TYPE="text/css" HREF="LavaStyles.css">
  </HEAD>
  
  <BODY>
    
    <H2 ALIGN="center">The <B><I><FONT COLOR="#FF0000">Lava</FONT></I></B>
    callback concept</H2>
    
    <P>Presently there does not exist a common understanding on how to support
      <B>event notification</B> / <B>callbacks</B> in modern object-oriented
      programming languages. In the course of the <B><I><FONT COLOR="#FF0000">Java</FONT></I></B>
      development <B><I><FONT COLOR="#FF0000">Sun Microsystems</FONT></I></B>
      has replaced the original event handling concept by a new philosophy based
      on <I>event listeners</I>, <I>adapter classes</I>, and <B><I><FONT COLOR="#FF0000">Java</FONT></I></B>
      language extensions introducing <I>anonymous</I> and <I>inner classes</I>.
      <B><I><FONT COLOR="#FF0000">Microsoft</FONT></I></B> has made (and
      withdrawn) a proposal for an own callback-specific <B><I><FONT COLOR="#FF0000">Java</FONT></I></B>
      language extension.</P>
    
    <P>The problem is primarily to find a truly object-oriented way to pass an
      <B>event description, provided by the notifying server</B>, as well as
      one or more <B>&quot;client data&quot;</B><I> </I>arguments, provided by
      the notification client, in a callback parameter list, without requiring
      the server to &quot;know&quot; and to insert those client data arguments
      at the time when the callback function is called.</P>
    
    <P>We felt that the present <B><I><FONT COLOR="#FF0000">Java</FONT></I></B>
      solution is too indirect and awkward. It is based on intermediate <B>listener
      objects</B> that contain the client data and on auxiliary constructs like <B>
      inner, adapter, and anonymous classes</B>. We  prefer a solution
      allowing the event-consuming client object to direct a quite
      straightforward request to the event-producing server object:</P>
    <BLOCKQUOTE>
      
      <P><b>Call my member function <I>self.cbf(evtDesc,cd1,cd2,...)</I>
        when your event <I>evtSpec</I> occurs.</b></P>
      
    </BLOCKQUOTE>
    
    <P>Here the first argument <i>evtDesc</i> of our callback function <i>cbf</i> will describe the details of
        the server event, and <i>cd1</i>, <i>cd2</i>, ... are client data
        objects that are provided by the client already together with this
        request. <i>&quot;evtSpec&quot;</i> is an enumerated item of some enumerated type
    <i>ServEv</i>&nbsp;
      that distinguishes the supported server events. The server may provide
        several such enumerated types <i>ServEv </i>each of which corresponds to one class
    <i>ServEvDesc</i> of server event descriptions that may be used for <i>evtDesc</i>.
    <b>Note: </b><b>The server does not need to know the
        declaration of the callback function cbf!</b></P>
    
    <P>This is exactly what you can express in <B><I><FONT COLOR="#FF0000">Lava</FONT></I></B> 
    if a client wants to register a callback with a server.</P>
    
    <P>To meet the requirements of object-orientation and static type checking
      <B><I><FONT COLOR="#FF0000">Lava</FONT></I></B> provides a single
      callback-specific <B><FONT COLOR="#0000FF">callback</FONT></B>
 expression and makes use of <B><I><FONT COLOR="#FF0000">Lava</FONT></I></B>
      <A HREF="PatternsFrameworks.htm">virtual types</A> moreover. The special
    expression could be called a <I>&quot;canned function call&quot;.</I> It
      wraps up the above expression <I>self.cbf(&lt;event&gt;,cd1,cd2,...)</I>
      together with <i>evtSpec</i> in a special data object of class <I>SE_Callback</I>
      (which the server has derived to this end from the basic <B><I><FONT COLOR="#FF0000">Lava</FONT></I></B> class
      <I>Callback</I> defined in the basic include file <B><FONT COLOR="#FF0000"><I>std.lava</I></FONT></B>).
    The declaration of <i>Callback</i> in <b><i><font color="#FF0000">std.lava</font></i></b>
    is nested within class <i>Callbacks,</i> which extends class <i>Set</i> and
    is used as the parent of all types of lists of registered callbacks.
    </P>
    
    <P>Class <I>Callbacks</I> has two virtual (parameter) types: <I>&quot;eventSpec
      = Enumeration&quot; </I>and <I>&quot;eventDesc&quot; </I>(an abstract
      virtual type). These are assigned new values <i>ServEv </i> and <i>ServEvDesc</i>,
      respectively, when the server programmer derives (one or several classes) <I>SE_Callbacks</I> from
      <I>Callbacks</I>.&nbsp;</P>
    
    <P>The (executable) <B><FONT COLOR="#0000FF">callback</FONT></B>
      construct allows the callback client to &quot;freeze&quot; the desired
      callback function invocation in a state where its first (= event) argument
      <I>&lt;event&gt;</I> is not yet known but everything else is known.</P>

<PRE><FONT FACE="Courier New">  <B><FONT COLOR="#0000FF">  declare</FONT></B>
      SE_Callback cb
    <B><FONT COLOR="#0000FF">do</FONT></B>
      cb <B><FONT COLOR="#0000FF">&lt;==</FONT></B> <B><FONT COLOR="#0000FF"><FONT COLOR="#0000FF">callback</FONT> from</FONT></B> SE_Callback:
               <b><font color="#0000FF">call</font></b> self.cbf(&lt;event&gt;,cd1,cd2,...)
             <font color="#0000FF"><b>when</b></font>
               evtSpec
             <B><FONT COLOR="#0000FF">#callback</FONT></B>;
      server.register(cb) <i><font color="#008080">register callback cb</font></i>
    <B><FONT COLOR="#0000FF">#declare</FONT></B></FONT></PRE>
    
    <P><b>At programming time</b> <I><B><FONT COLOR="#FF0000">LavaPE</FONT></B></I>
      checks the <B><FONT COLOR="#0000FF">callback</FONT></B> expression and
      this way makes sure that the class of the first <i> formal</i> parameter of <I>cbf</I>
      equals VT &lt;<I>eventDesc&gt; (=ServerEvent)</I> or a base class thereof, and <B><I><FONT COLOR="#FF0000">LavaPE</FONT></I></B>
      allows you to select the event type only from the
      enumerated type &lt;<I>eventSpec&gt;</I> (= <i>ServEv</i>). </P>
    
    <P><b>At run time</b> the actual callback execution is carried out by a native function <i>Execute</i>
      of class <i>Callback</i>. It replaces the first (placeholder) argument <I>&lt;event&gt;</I>
      of <I>cbf</I> with the actual argument <I>actEvent</I> and then executes the &quot;canned call&quot; <I>cb</I>.&nbsp;</P>
    
    <P>The <B><I><FONT COLOR="#FF0000">Lava</FONT></I></B>
    <a href="PatternsFrameworks.htm#VT">virtual type</a> mechanism ensures (at programming time) that the
      actual parameter <I>actEvent</I> of <i>NotifyClients</i> and of <i>Execute</i>
      is compatible with the corresponding (virtual) formal parameter type <I>eventDesc</I>
      (= <I>ServerEvent</I>). Consequently <I>actEvent</I> is also compatible
      with the first formal parameter of the client's callback function <I>cbf</I>.</P>
    
    <P><b>For further details see
      classes <I>CallbackServer</I>  and <i>Callback </i>in <FONT COLOR="#FF0000">std.lava</FONT> and our <A HREF="CallbackSample.htm">callback sample</A>.</b></P>
  </BODY>
</HTML>