<!DOCTYPE html PUBLIC "-//SoftQuad//DTD HoTMetaL PRO 4.0::19971010::extensions to HTML 4.0//EN"
"hmpro4.dtd">
<HTML>
  <HEAD>
    <meta http-equiv="Content-Language" content="en-us">
    <META CONTENT="text/html; charset=windows-1252">
    <META NAME="GENERATOR" CONTENT="Microsoft FrontPage 5.0">
    <META NAME="ProgId" CONTENT="FrontPage.Editor.Document">
    <TITLE>Unsolved problems</TITLE>
    <LINK REL="STYLESHEET" TYPE="text/css" HREF="LavaStyles.css">
  </HEAD>
  <BODY>
    <P ALIGN="right">
      <FONT SIZE="1" FACE="Comic Sans MS">All things are hard before they become easy<BR>
       (Moslik Saadi)</FONT>
    </P>
    <H2 ALIGN="center">
      <IMG SRC="../images/catThinks.gif" ALT="Rethinking pussy" WIDTH="306" HEIGHT="100">
    </H2>
    <H2 ALIGN="center">
      Urgent problems in current programming languages that call for much rethinking<BR>
    </H2>
    <H3>
      1. Programs should no longer be "written"
    </H3>
    <P>
      It's time to finally overcome the antediluvian technology of software production using text editors. Programs should no longer be "written" but constructed/composed in Lego-like fashion from
      basic constructs, using <B>structure editors</B> rather than text editors. Particularly the executable portions of programs are the last bastions of textual programming that remain to be
      captured by <STRONG><B>"point-and-click" technology</B></STRONG>.
    </P>
    <P>
      Structure editors are also a valuable and almost indispensable basis for the realization of powerful <B><A HREF="Refactoring.htm">restructuring / refactoring</A></B> operations, which should be
      supported by every modern IDE (Integrated Development Environment).
    </P>
    <P>
      <A HREF="PointAndClick.htm"><B><I><FONT COLOR="#FF0000">Lava</FONT></I> solution</B></A>
    </P>
    <H3>
      <A NAME="sepItfImpl"></A>2. "Interfaces" and "implementations" should be strictly separated
    </H3>
    <P>
      Older, non-object-oriented languages like <FONT COLOR="#FF0000"><STRONG><I>Modula-2</I></STRONG></FONT> and <FONT COLOR="#FF0000"><STRONG><I>Ada</I></STRONG></FONT>, that were based on
      "abstract data types", had already achieved a clean syntactic and semantic <STRONG>separation of "interfaces" and "implementations"</STRONG>. It's high time to regain this very important
      achievement in object-oriented languages in a comparably clean way. The distinction made by <FONT COLOR="#FF0000"><STRONG><I>Java</I></STRONG></FONT> between <STRONG>interfaces</STRONG> and
      (abstract or concrete) <STRONG>classes</STRONG> does not yet fully achieve this strict separation, since the type of an object may be both an interface or a class in <FONT COLOR="#FF0000"><B>
      <I>Java</I></B></FONT>. Moreover, <FONT COLOR="#FF0000"><B><I>Java</I></B></FONT> interfaces are groups of public <I>functions</I> only. They are unable to expose public <I>data members</I>.
    </P>
    <P>
      You can, of course, provide <A NAME="setGetFunctions"></A>GET and SET access functions as a substitute. But even then we should prefer 1. to hide these access functions in the <I>
      implementation</I> of the respective interface, 2. to expose the respective property (for instance the "account balance") in the <I>interface</I> (perhaps protected by a "read-only" attribute),
      and 3. to allow the programmer to directly refer to this member object in assignments or read-references, rather than to explicitly call access functions.
    </P>
    <P>
      <B><A HREF="SepItfImpl.htm"><I><FONT COLOR="#FF0000">Lava</FONT></I> solution</A></B>
    </P>
    <H3>
      3. <A NAME="stateValue"></A>Two very different categories of objects should be distinguished
    </H3>
    <P>
      It's time to <B>overhaul the object notion itself</B> which would presently be used to describe two <I>conceptually very different</I> categories of things, for instance bank accounts as well
      as money transfer orders:
    </P>
    <UL>
      <LI>
        A bank account is a variable <B>state</B> or <B>service object</B>. It doesn't make much sense to <I>copy</I> such an object or to pass it <I>by value</I>, since the state histories of the
        resulting two objects would from this moment on proceed independently. <I>Cloning</I> would basically contradict the semantics and purpose of a state object like a bank account: You cannot
        multiply your money by duplicating your bank account. Moreover, a state object would in most cases have exclusive command over its internal state, which may be changed again and again, but
        only by calling the object's methods, and this state change has the nature of a <B>transaction</B> typically. State objects would provide various services grouped into one or several function
        call interfaces. In particular, <FONT COLOR="#FF0000"><STRONG><I>CORBA </I></STRONG></FONT>objects and component objects in <FONT COLOR="#FF0000"><STRONG><I>COM</I></STRONG></FONT> are
        state/service objects. State/service objects are typically used as <EM>shared memory</EM> between concurrent applications/processes/threads.<BR>
      </LI>
      <LI>
        A money transfer order is a <B>value object</B> or <B>structure</B>that becomes <B>"immutable"</B> after <B>"completion"</B>: A (completed) value object represents an immutable complex value.
        Since it is immutable it doesn't matter to pass it <I>by reference</I> for efficiency reasons. Since it is just a complex value it may also be passed <I>by value</I> without contradicting its
        purpose and semantics. Value objects <I>will</I> typically be passed <I>by value</I> whenever they are passed to another <I>component</I> (see below), thereby entering a separate address
        space and possibly also the realm of another programming language. A value object is typically <EM>filled in</EM> by directly assigning values to its individual "fields" (preferably without
        explicitly calling "access methods" to this end). In addition, a money transfer order form is "signed" after <I>completion</I>, and it must not be changed any more thereafter: it is <B>
        "frozen"</B>. State/service objects are never <EM>"frozen"</EM> but open for ever new modifications, but their member variables will typically be value objects which are replaced by such
        modifications. A value object can be assigned to a variable or passed as a parameter to functions only <EM>after</EM> it has been <EM>"completed"</EM> by assigning a value to each of its
        non-optional) fields (= member objects).
      </LI>
    </UL>
    <P>
      <B><A HREF="TwoObjectCategories.htm"><I><FONT COLOR="#FF0000">Lava</FONT></I> solution</A></B>
    </P>
    <H3>
      <A NAME="components"></A>4. Future languages should provide a unified view of object- and component-orientation
    </H3>
    <P>
      A new object-oriented and component-aware language should clarify the relationship between program-<I>internal</I> objects and <EM>external</EM> component objects that "live" in address spaces
      of their own and that are possibly implemented in other languages. It should provide unified language constructs for describing and using the interfaces and implementations of internal as well
      as component objects. Based on these constructs, it should be easy to incorporate in particular <FONT COLOR="#FF0000"><STRONG><I>COM</I></STRONG></FONT>, <FONT COLOR="#FF0000"><STRONG><I>
      CORBA</I></STRONG></FONT>, and <FONT COLOR="#FF0000"><STRONG><I>JavaBeans</I></STRONG></FONT> objects. <B>"Intelligent" interaction of components</B> (compound documents, embedding and linking
      of user interfaces, drag-and-drop, clipboard,...) should also be supported. <B>Databases</B> and <B>files</B> should appear as special (<EM>persistent</EM>) component objects having specific
      interfaces.
    </P>
    <P>
      A basic requirement of a properly integrated component notion is that your programming language should clearly exhibit the difference between state objects (that can only be passed by reference
      to the methods of components or "external/remote objects") and value objects (that may or even must be passed by value, without corrupting their semantics).
    </P>
    <P>
      Another requirement, in this same context of parameter passing, is that your language should allow you to clearly delineate the "borders" of objects that are to be passed by value. This amounts
      to a proper distinction between "constituents" and "acquaintances" of objects (see below).
    </P>
    <P>
      <B><A HREF="Components.htm"><I><FONT COLOR="#FF0000">Lava</FONT></I> solution</A></B>
    </P>
    <H3>
      <A NAME="patterns"></A>5. Reusable design patterns / frameworks call for proper language support
    </H3>
    <P>
      A modern object-oriented language should properly support <STRONG>design-patterns / frameworks</STRONG> since they provide new, additional ways of software reuse. We need a way to <FONT COLOR= 
      "#FF0000"><B><I>collectively</I></B></FONT> specialize <B>groups</B> of parameterized classes. <B>Single-class macro constructs</B>, like "templates" in <FONT COLOR="#FF0000"><STRONG><I>
      C++</I></STRONG></FONT> or "generic types" in&nbsp; <FONT COLOR="#FF0000"><B><I><A NAME="Eiffel1"></A></I></B><STRONG><I>Eiffel</I></STRONG></FONT> won't do.
    </P>
    <P>
      We generally believe that templates / generic classes and their conformance rules in <FONT COLOR="#FF0000"><B><I>C++</I></B></FONT> and<FONT COLOR="#FF0000"><B><I>Eiffel</I></B></FONT> are too
      hard to manage and to comprehend. They tend to produce almost incomprehensible "template libraries" which are very powerful in principle but far away from providing easily and readily reusable
      designs.
    </P>
    <P>
      The conventional perspective on "templates" or "generic classes" is that they are a kind of <B>macros</B> that have to be <B>"instantiated" (meaning text substitution)</B> in order to become
      concrete classes that can be used to specify the types of objects. In order to overcome the apparent problems inherent in this view (complex nested instantiation expressions, complex type
      conformance rules, code replication with huge storage requirements) our <FONT COLOR="#FF0000"><B><I>Lava</I></B></FONT> design proposes a transition from this <B>"macro instantiation view"</B>
      to more unified and universal class and package notions including parameterized classes and packages (roughly = groups of classes) and an equally unified <B>derivation notion</B> that covers
      also to <B>the [collective] specialization of parameterized [groups of] classes</B>.
    </P>
    <P>
      <B><A HREF="PatternsFrameworks.htm"><I><FONT COLOR="#FF0000">Lava</FONT></I> solution</A></B>
    </P>
    <H3>
      <A NAME="typeCasts"></A>6. Strongly typed object-oriented programming languages should not need "type casts"
    </H3>
    <P>
      Type casts would be used primarily as <B>repair measures</B> in cases where the programmer knows that the run time type of an object is actually more derived than the static type of the
      containing variable, and he/she needs to use features of the more derived "dynamic" type. Type casts are not only ugly, nasty, and annoying but much worse: their justification can only be
      assessed on the basis of a more comprehensive understanding of the dynamic program behavior in general. <B>Possible reasons why type casts are used</B> nevertheless or may even be inevitable in
      contemporary statically typed object-oriented programming languages:
    </P>
    <UL>
      <LI>
        <B>Non-object-oriented programming style:</B> The program branches over explicit "type indicators" contained in the objects rather than calling polymorphic ("virtual") functions. This should
        be avoided wherever possible but may be justified in rare cases. We should prefer to provide a special <B><A NAME="typeSwitch"></A> "type switch"</B> statement rather than type casts for
        these cases in order to restrict its usage to just this situation and to discourage and impede bad programming style. (The latter can be hidden much easier behind type casts than behind a
        rather big and conspicuous type switch statement, particularly if it has only one type branch that is abused as a substitute for the desired type cast.)<BR>
      </LI>
      <LI>
        <B>A notion of class derivation and specialization that is too rigid and restricted :</B>
      </LI>
    </UL>
    <BLOCKQUOTE>
      <OL>
        <LI>
          You cannot specialize parameters of methods on class derivation.<BR>
        </LI>
        <LI>
          You cannot specialize data members of a class when defining a derived class.<BR>
        </LI>
        <LI>
          You cannot express collective specialization of several classes that refer to each other.
        </LI>
      </OL>
    </BLOCKQUOTE>
    <P>
      In all these cases you know at programming time that in the derived classes (or group of related derived classes) certain member variables or function parameters will actually be of a more
      derived type than in the corresponding base class(es) but the derivation mechanism of your programming language does not allow you to express this. So you retain the original types assigned to
      these variables in the base class(es) and resort to type casts in the derived class(es).
    </P>
    <P>
      <B><A HREF="TypeCasts.htm"><I><FONT COLOR="#FF0000">Lava</FONT></I> solution</A></B>
    </P>
    <H3>
      7. <A NAME="singleAssign"></A>Abandoning "go to" has clarified the control flow of programs,<BR>
       "single-assignment" will clarify the data flow
    </H3>
    <P>
      The "variable" notion of present programming languages would view a <B>variable as a "data container"</B> to which you can again and again assign a new content/value ("multiple assignment"),
      and to reference a variable means to reference its "current content". But in order to correctly locate the origin of its "current content" you must exactly understand the dynamic control flow
      of the program. If you admit "global variables" that can be accessed from anywhere in the program then this will mostly become even more difficult and error-prone .
    </P>
    <P>
      We expect that <B>abandoning "multiple assignment"</B>, the conventional "variable = data container" view, and particularly "global variables" <B>will greatly clarify the data flow</B> of
      programs. It will be much easier then to locate the origin of values. The "<A HREF="SingleAssigLogSem.htm">single-assignment</A>" rule reads:
    </P>
    <UL>
      <LI>
        At run time, a value may be assigned to a variable only once in every program branch within the scope of the variable.
      </LI>
    </UL>
    <P>
      You just need to follow the current program branch statically in upward direction to find out whether and where a value has been assigned to a variable that you are about to reference. This
      analysis can be performed automatically at programming time.
    </P>
    <P>
      <A NAME="loops"></A>A particular consequence of "single-assignment" is that conventional <B>sequential loops</B> that forward information via some variables from one pass of the loop to the
      next are excluded and <B>have to be replaced by recursive function calls</B>. In our opinion this is a desirable step towards a more mathematical semantics and understanding of programs and
      contributes to the clarification of data flow.
    </P>
    <P>
      <B>"Non-recursive" loops</B>, however, (whose passes could in principle be executed concurrently,) may be expressed by <B>"foreach"</B> and <B>"exists" quantifiers</B> running through finite
      sets of objects.
    </P>
    <P>
      <B><A HREF="LavaOverview.htm#dataFlow"><I><FONT COLOR="#FF0000">Lava</FONT></I> solution</A></B>
    </P>
    <H3>
      <A NAME="pointers"></A>8. We need an application-level pointer notion to distinguish "constituents" and "acquaintances" of objects
    </H3>
    <P>
      If you would like to retain a <B><I>copy</I></B> of a complex object that might be subject to further changes in the future, or if an object shall be <I>"<B>passed by value"</B></I> to some
      function, or if yu want to <B><I>compare</I></B> complex objects (member by member) then you would like to know which of its members/attributes represent real <B>"constituents"</B> of this
      object and which are just <B>references/pointers</B> to other, independent objects. In other words: you would like to specify the "borders" of complex objects, or to express what <B>
      "belongs"</B> to an object and what are just <B>"acquaintances"</B>. Particularly when crossing component borders you have to make such a distinction, as is well known from <B><I><FONT COLOR= 
      "#FF0000">DCOM</FONT></I></B> and <FONT COLOR="#FF0000"><B><I>CORBA</I></B></FONT>. A component-oriented language should take this into account.
    </P>
    <P>
      You must not confuse this <I>logical, application-level</I> distinction with the <I>implementation</I> issue whether an object and its constituents are all allocated within the same contiguous
      block of storage ("embedded constituents", as in <B><I><FONT COLOR="#FF0000">C++</FONT></I></B> objects and the "expanded classes" of <B><I><FONT COLOR="#FF0000"><A NAME="Eiffel2">
      </A>Eiffel</FONT></I></B>), or whether constituents are linked by <I>address pointers</I> in a low-level sense to their "owners". A programming language may very well support both "linked" and
      "embedded" constituents, while "embedded acquaintances" would be a rather contradictory notion and would not make much sense.
    </P>
    <P>
      <I>Summary</I>: Neither the low-level address semantics of <B><I><FONT COLOR="#FF0000">C++</FONT></I></B> pointers nor the complete absence of an explicit pointer notion in <FONT COLOR=
      "#FF0000"><B><I>Java</I></B></FONT> are satisfactory solutions but we need a proper distinction between "constituents" and "acquaintances" of complex objects, irrespective of the question
      whether constituents are implemented as <I>embedded</I> or as <I>linked</I> constituents.
    </P>
    <P>
      <B><a href="PointersRefCounts.htm"><I><FONT COLOR="#FF0000">Lava</FONT></I> solution</a></B>
    </P>
    <H3>
      <B><A NAME="iniChecks"></A>9. Inadvertent use of uninitialized data should 
      be prevented already at programming time</B>
    </H3>
    <P>
      Inadvertent use of uninitialized data frequently causes programs to crash in a way that is hard and time-consuming to disentangle, which in turn gives rise to immense costs. So it's time to
      undertake really serious efforts to prevent such situations wherever possible by static and run-time checks. Static initialization checks are preferable, of course, but 
      will require a
      fundamental revision of expressive means for executable code in order to 
      make these checks as complete/comprehensive/effective as possible.
    </P>
    <P>
      <B><A HREF="IniChecks.htm"><I><FONT COLOR="#FF0000">Lava</FONT></I> solution</A></B>
    </P>
    <H3>
      <A NAME="SQL"></A>10. "Embedded SQL" should finally be overcome
    </H3>
    <P>
      It's time to overcome the painful dissociation between programming languages and database languages ("embedded SQL"). Many people have got accustomed to this schism to a degree that they deem
      it to be a law of nature. But in practice <B>it is highly unproductive to learn two languages and to bridge the syntactic and semantic gap between them again and again</B>. The increasing
      importance of object-oriented databases is a strong motivation to look for more unified expressive means for data definition, data manipulation and query, particularly for searching and
      accessing complex container objects, no matter whether they are <I>persistent</I> database objects or <I>transient</I> program-internal objects.
    </P>
    <P>
      <B><A HREF="DatabaseIntegration.htm"><I><FONT COLOR="#FF0000">Lava</FONT></I> solution</A></B>
    </P>
    <H3>
      <A NAME="SQL"></A>11. Low-level user interface builders should be overcome
    </H3>
    <P>
      The purpose of graphical user interfaces is to present a graphical 
      representation of selected internal application data structures to the 
      user and to allow her/him to manipulate these data structures by 
      point-and-click and key-press operations. Present UI builders work on a 
      very low level and require a great lot of manual work to establish this 
      mapping between internal data structures and external visible 
      representation and to add user interaction handlers to this 
      representation. UI builders are big and complicated tools and they have 
      little or no knowledge of the actual, complex application data structures. 
      The programmer would have to construct intermediate auxiliary data 
      structures that are required by the UI programming interface.</P>
    <P>
      Presently this entire UI construction process is very costly and very 
      cumbersome. Our idea is to replace this process by a more direct, 
      semi-automatic and annotation-controlled mapping from complex application 
      data structures to complex visual representations: Annotations to the 
      components and elements of an application data structure would specify the 
      details of the associated visual representation, and a kind of &quot;user 
      interface interpreter&quot; would read these annotations at run time and 
      constructs the visual representations.</P>
    <P>
      <B><I><FONT COLOR="#FF0000">Lava</FONT></I> solution</B>: Under 
      development.</P>
    <H3>
      <A NAME="synch"></A>12. Multi-threading, transactions, and synchronization should be treated in a purely declarative way
    </H3>
    <P>
      Transaction programming, multi-threading, inter-process communication / synchronization, distributed processing are inexhaustible sources of errors, frustration, and intricateness that should
      be drained finally. It would in particular be an invaluable advantage if you could handle all these problems in a <B>purely declarative high-level style</B>, i.e., without needing any delicate
      low-level executable transaction, communication, and synchronization primitives like start_transaction / commit / abort, or semaphores / monitors / mutexes / conditions / events / send /
      receive / wait. Transaction abort should appear as a quite normal case of throwing an exception.
    </P>
    <P>
      <B><A HREF="Transactions.htm"><I><FONT COLOR="#FF0000">Lava</FONT></I> solution</A></B>
    </P>
    <H3>
      <A NAME="organization"></A>13. Programming languages should become "organization-aware"
    </H3>
    <P>
      A language with all these characteristics should also be <STRONG>organization-aware</STRONG>: If you can talk about interfaces to persistent component objects then you should also be able to
      talk about object ownership in terms of persons, or more generally: organizational units (OU's), of the application environment. Likewise, it should be possible to specify OU's that are to be
      contacted via some display by interactive components of an application. Data ownership and contact addresses for personal interaction need not be specified in terms of one single organizational
      name space. The various types of conventional addressing schemes currently in use should be supported equally well, like file and computer names, ftp, http, e-mail addresses.
    </P>
    <P>
      <B><I><FONT COLOR="#FF0000">Lava</FONT></I> solution</B>: For future 
      research.</P>
    <H3>
      <A NAME="security"></A>14. Programming languages should become "security-aware"
    </H3>
    <P>
      Once you can talk about data ownership and interactive responsibilities of OU's it is obvious that you would also like to talk about security rules and policies. You would like to restrict the
      access to persistent data and the invocation of services, and in addition to these <I>"preventive"</I> security measures, it should be easy to integrate <I>"defensive"</I> measures (using
      digital signatures and encryption) into applications.
    </P>
    <P>
      Preventive and defensive security is not just a matter of providing proper library functions but should be supported directly on the language level:
    </P>
    <UL>
      <LI>
        <STRONG>Preventive security</STRONG> means essentially that service interfaces or individual functions of such interfaces possibly may be invoked only if proper privileges have been acquired
        before by the invoking person, OU, or other state object. So it would be most natural to specify such privileges as part of the respective service interface specification.<BR>
      </LI>
      <LI>
        <STRONG>Defensive security</STRONG> means to protect entire documents or selected individual parts of structured data objects by encryption or by adding digital signatures to these objects.
        This requires proper ways of specifying, which parts of an object should be encrypted or signed (by which signature). So it would be most natural again to make this specification a part of
        the respective data object's type definition.
      </LI>
    </UL>
    <P>
      <B><I><FONT COLOR="#FF0000">Lava</FONT></I> solution</B>: For future 
      research.</P>
    <HR>
    <P>
      After all, the <FONT COLOR="#FF0000"><STRONG><I>Lava</I></STRONG></FONT> development can be viewed partly as an attempt to <A HREF="PicketFence.htm">capitalize on the gaps</A> and omissions
      inherent in <FONT COLOR="#FF0000"><STRONG><I>Java</I></STRONG></FONT>, <FONT COLOR="#FF0000"><STRONG><I>Visual Basic</I></STRONG></FONT> and other popular contemporary programming languages.
    </P>
  </BODY>
</HTML>