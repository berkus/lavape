<!DOCTYPE HTML PUBLIC "-//SoftQuad//DTD HoTMetaL PRO 4.0::19971010::extensions to HTML 4.0//EN" "hmpro4.dtd">
<html>
<head>


  
  <meta http-equiv="Content-Language" content="en-us">


  
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1252">


  
  <meta name="GENERATOR" content="Microsoft FrontPage 5.0">


  
  <meta name="ProgId" content="FrontPage.Editor.Document">

  


  
  <title>Initialization checks</title>
  <link rel="STYLESHEET" type="text/css" href="LavaStyles.css">
</head>


<body>


<h2 align="center"><strong>Complete
initialization checks</strong></h2>


<p><b>Inadvertent use of uninitialized data or propagation of null values (<font color="#0000FF">Ø</font>) 
to <a href="dialogs/MemVarBox.htm#mandatory">mandatory</a> variables</b> frequently causes
programs to crash in ways that are hard and time-consuming to
disentangle, and this gives rise to immense costs in turn. The attempt to
prevent such situations has therefore been a constitutive design goal
of the <i><font color="#ff0000"><b>Lava</b></font></i>
development. </p>


<p>More precisely, our goal was to prevent missing initialization and 
inadvertent use of null values by <b>static checks (i.e., at
programming time)</b> wherever possible. The <font color="#FF0000"><i><b>Lava</b></i></font> 
releases prior to 0.9 didn't fully achieve this. The introduction of the 
notion of <b>
<a href="UnfinishedObjects.htm">closed objects</a></b> together with new 
expressive means (the <font color="#0000FF"><b>
<a href="whatsThis/IfdefElse.htm">ifdef</a></b></font> conditional 
statement and the <font color="#0000FF"><b>
<a href="whatsThis/IfdefElse.htm#elseExpr">else</a></b></font> expression) in 
release 0.9 have changed <font color="#FF0000"><i><b>Lava</b></i></font> into an object-oriented programming language (the first?) that <b>
completely prevents missing initialization and inadvertent use of null values 
already at programming time, i.e., by purely static checks</b>.</p>


<p>This could be achieved only by a major
revision of the expressive means for executable code, as compared to more traditional wide-spread 
procedural and object-oriented programming languages. In particular,
we have</p>


<ul>


  <li><a href="RepetComputSamples.htm">replaced
traditional loop constructs</a> by recursive function calls and
bounded quantifiers,</li>


  <li>replaced the traditional view of program variables as
"reusable data containers" by a "<a href="SingleAssigLogSem.htm">single-assignment</a>"
  (or &quot;computed constant&quot;) view of variable usage, and</li>


  <li>eliminated parameter passing "by reference" in favor of an
unambiguous distinction between input and output parameters of methods.</li>


  <li>Moreover, we have introduced specific expressive means (the
  <font color="#0000FF"><b><a href="whatsThis/IfdefElse.htm">ifdef</a></b></font> conditional statement and the
  <font color="#0000FF"><b><a href="whatsThis/IfdefElse.htm#elseExpr">else</a></b></font> expression) that allow us to prevent 
  inadvertent <font color="#0000ff"><b>&Oslash;</b></font>-to-mandatory 
  assignments (see below).</li>


  <li>In cases where objects point to each other it is unavoidable that 
  initializers of &quot;parent&quot; objects pass references to &quot;self&quot; or other not yet completely 
  initialized objects to initializers of child objects (which will then use 
  these references to point to the parent (or grandparent or other unfinished) object). This passing of unfinished 
  objects as parameters, however, has to be secured against inadvertent access 
  to not yet initialized sub-objects. For details see the dedicated section on
  <b>
  <a href="UnfinishedObjects.htm">unfinished objects</a></b>.</li>


</ul>


<h3>A) Missing initialization</h3>


<p>Missing initialization has to be prevented with respect to</p>


<ol>


  <li><b>local</b> variables,</li>


  <li><b>member </b>variables of classes, and</li>


  <li><b>Output parameters</b> of function calls.</li>


</ol>


<p>(Note that <i>global variables</i> have been
abolished anyway in <font color="#ff0000"><i><b>Lava</b></i></font>
in favor of a purely local, explicit data flow, in order to facilitate
the analysis and comprehension of data flow in complex programs and to avoid the 
obfuscating and confusing effects of &quot;far-distance dependencies&quot; within complex 
applications.)</p>


<p>Before you proceed, you should have understood how <font color="#ff0000"> <i><b>Lava</b></i></font>
<a href="RepetComputSamples.htm">replaces traditional loop
constructs</a> and that this implies:</p>


<p><b><span lang="de">F</span>or every
read access to a <font color="#ff0000"><i>Lava</i></font>
variable you can easily find the origin of the current value of this
variable by following the containing program branch in upward direction
(unless the variable is an input variable and therefore a value is
assigned to it already <i>outside</i> this
function).&nbsp;</b></p>


<p>Now let's return to the three kinds of initialization
problems. Note that <i><font color="#ff0000"><b>LavaPE
</b></font></i>1. <a href="EditExec.htm">
shows executable code</a> in separate windows, every function and
initiator body and every invariant in a window of its own, and 2. after
every single editing step in the <font color="#ff0000"><i><b>LavaPE</b></i></font>
structure editors <font color="#ff0000"><i><b>LavaPE</b></i></font>
performs a static check on all the <i><font color="#ff0000"><b>Lava</b></font></i>
code that is currently being presented in any open Window.</p>


<h4>1. Local variables</h4>


<p>Local variables may be introduced in several different ways,
i.e., by several constructs:</p>


<ul>


  <li><font color="#0000ff"><b>declare</b></font>
(just declares new local variables in the usual sense),</li>


  <li><font color="#0000ff"><b>foreach</b></font>
(universal quantifier ranging over some finite set of objects),</li>


  <li><font color="#0000ff"><b>exists</b></font>
(existential quantifier ranging over some finite set of objects),</li>


  <li><font color="#0000ff"><b>select</b></font>
(<font color="#ff0000"><i><b>Lava</b></i></font>
counterpart of the <font color="#ff0000"><i><b>SQL</b></i></font>
select expression),</li>


  <li><font color="#0000ff"><b>type</b></font> (branches over the run time type 
  of an expression value),</li>


  <li><font color="#0000FF"><b>try ... catch</b></font> (branches over the type 
  of an <a href="ExceptionSamples.htm">exception</a> object.</li>


</ul>


<p>which all assign completely initialized objects to the respective local variables that
they introduce, except for the declare construct. So we need to
consider only <i> declared</i> variables.</p>


<p>For every read access to a <i>declared</i> local
variable <font color="#ff0000"><i><b>LavaPE</b></i></font>
checks (statically, = at programming time) if a value is assigned to
this variable above the place of reference in the same
program&nbsp; branch and reports an error otherwise. A somewhat
unusual consequence of this is that a newly declared local variable is
always displayed bold and red initially, marking an error, since there
has not yet been assigned a value to it. </p>


<h4>2. Member variables</h4>


<p>In order to guarantee that all non-optional member variables
of <font color="#ff0000"><i><b>Lava</b></i></font>
objects are properly initialized, <font color="#ff0000"><i><b>Lava</b></i></font>
enforces an unusually stringent initialization discipline<span lang="de">:</span></p>


<ol>


  <li>New <font color="#ff0000"><i><b>Lava</b></i></font>
objects are created using the <font color="#0000ff"><b>new</b></font>
expression, which requires the specification of an "initializer"
associated with the new object's class.</li>


  <li><font color="#ff0000"><i><b>LavaPE</b></i></font>
makes sure (by purely static checks) that <b>every initializer assigns a
value to every non-optional member variable of this class in each of
its branches</b>.</li>


  <li>You can modify these values within the (optional) <font color="#800080"><b>but</b></font> clause
of the <font color="#0000ff"><b>new</b></font>
expression and in this way <i> customize</i> the object
before its completion.</li>


  <li>When a new object leaves the <font color="#0000ff"><b>new</b></font>
construct <font color="#ff0000"><i><b>Lava</b></i></font>
marks it as <i> finished</i>. <font color="#ff0000"><i><b>Lava</b></i></font>
makes sure (by run time checks) that you cannot pass an unfinished
object (from within an initializer or a <font color="#800080"><b>but</b></font>
clause) as an input parameter to any function.<br>


    <br>


This enforces essentially a <b>strict bottom-up construction of
new objects from member objects</b> that have to be constructed
first.</li>


</ol>


<p>Two concessions will (to some degree) soften the "pain" caused
by such a strict bottom-up construction discipline:<i> </i></p>


<p><i>From within an initializer</i></p>


<ul>


  <li>you may use <i>self</i>&nbsp; for calling
a method of self's class: self.method(...), after all non-optional
members of <i>self</i> have been initialized, although the
new object has not yet been marked as <i>finished</i> in
this case.</li>


  <li>you may pass a (not yet completely initialized) <i>self</i>
object as an input parameter to <i>another initializer</i>:
This is inevitably needed if you would like to establish a "backward" <a href="PointersRefCounts.htm">pointer</a> from a member
object to its containing parent object.</li>


</ul>


<p>In more detail, point 2 above means that from every "return
point" of the function body the check follows the respective branch in
upward direction and makes sure that a value is assigned to every
non-optional output parameter in this branch.</p>


<p>A "return point" may be the end of the function body or a <a target="_blank" href="whatsThis/FailSucceed.htm"><font color="#0000ff"><b>succeed</b></font></a>
or <a href="whatsThis/FailSucceed.htm"><font color="#0000ff"><b>fail/throw</b></font></a>
statement. The <a href="whatsThis/FailSucceed.htm"><font color="#0000ff"><b>throw</b></font></a>
statement specifies an expression whose value designates an exception
that is to be thrown.</p>


<p>If a function has output parameters (see below) then it must
not be left without throwing an exception (checked at programming
time). This applies also to initializers of classes.</p>


<p>An exception-throwing <a href="whatsThis/FailSucceed.htm"><font color="#0000ff"><b>throw</b></font></a>
statement is the <i>only</i> way to exit from a class
method or initializer if you cannot assign a value to every
non-optional output parameter. (Checked at programming time.)</p>


<h4>3. Output parameters</h4>


<p>First<font color="#ff0000"><b><i> </i></b></font>note that <font color="#ff0000"><i><b>Lava</b></i></font><b> </b>doesn't support parameter passing "by reference". In <i> <font color="#ff0000"><b>Lava</b></font></i><b>,</b>
function parameters are either input or output parameters. For
reference parameters it wouldn't be clear whether or not the function
assigns a value to them, whereas a <font color="#ff0000"><i><b>Lava</b></i></font>&nbsp;
function <b>must</b> assign a value to <b>every</b>
non-optional output parameter, and this is checked already at
programming time (= statically).</p>


<p>This is an essential prerequisite for all kinds of <font color="#ff0000"> <i><b>Lava</b></i></font>&nbsp;
initialization checks since only then you can also cover those cases
where a variable is initialized by being an actual output parameter of
a function call.</p>


<p>(Note: Though function parameters aren't passed &quot;by reference&quot; in
<font color="#FF0000"><i><b>Lava</b></i></font>, they are yet passed &quot;by 
address&quot; and never &quot;by value&quot; (= copied)). </p>


<p>Much like the member initialization checks (see above), the initialization 
checks for output parameters are performed at all return points of the function 
body.</p>


<p>An exception-throwing <a href="whatsThis/FailSucceed.htm"><font color="#0000ff"><b>throw</b></font></a>
statement is  the <i>only</i> way to exit from a
function if you cannot assign a value to every non-optional output
parameter. (Checked at programming time.)</p>


<p>In this way <font color="#ff0000"><i><b>Lava</b></i></font>
makes sure that undefined outputs cannot be used <b>inadvertently </b>by the caller of a failing function but only if the resulting exception
is caught and the respective output parameters are used nevertheless
thereafter. </p>


<p>(The worst thing that may happen then is that such an output
is <font color="#0000ff"><b>&Oslash;</b></font>:
then a null-pointer-exception will be thrown in turn, or you use the
output although its value may be meaningless in this case: that's your
own risk and should be avoided without reliable knowledge about the
function's implementation.)</p>


<h3><a name="optional"></a>B) Preventing <b><font color="#0000FF">Ø</font></b>-to-mandatory assignments</h3>


<p>In <font color="#FF0000"><i><b>Lava</b></i></font>, an expression that yields an 
<a href="dialogs/MemVarBox.htm#mandatory">optional</a> result (i.e.,
one that may assume the special value <font color="#0000ff"><b>&Oslash;</b></font>),
cannot be unconditionally assigned to a 
<a href="dialogs/MemVarBox.htm#mandatory">mandatory</a> variable in <font color="#ff0000"><b><i>Lava</i></b></font>,
but you must either enclose the assignment in the <font color="#0000FF"><b>then</b></font> 
clause of an <font color="#0000ff"><b><a href="whatsThis/IfdefElse.htm">ifdef</a></b></font>
statement (which tests whether the optional variable in the
<font color="#0000FF"><b>ifdef</b></font>-condition has a non-null value), or you must use an <font color="#0000ff"><b>
<a href="whatsThis/IfdefElse.htm#elseExpr">else</a></b></font>
expression or a chain of <font color="#0000ff"><b>else</b></font>
expressions  which finally provides an alternative expression that
yields a non-optional value.</p>


<hr>


<h3>Initialization in <font color="#FF0000"><i>Lava</i></font> compared to
<font color="#FF0000"><i>C++</i></font> / <font color="#FF0000"><i>Java</i></font> 
/ <font color="#FF0000"><i>C#</i></font></h3>
<p>The <b>definite assignment checks</b> of <b><font color="#FF0000"><i>Java</i></font></b> 
and <font color="#FF0000"><i><b>C#</b></i></font>, like those of
<font color="#FF0000"><b><i>Lava</i></b></font> (see above), ensure that a local 
variable is assigned before it is used. But the absence of the 
optional/mandatory distinction and of a clear distinction between input and 
output parameters makes it impossible to have a greater benefit from the 
analytical capabilities of the compiler. E.g., look at the following little
<font color="#FF0000"><i><b>Java</b></i></font> program:</p>

<blockquote>
<pre><font color="#0000FF">public class</font> Hello {
  <font color="#0000FF">public static</font> void main(String[] args) {
    A a, a2;
		
    a = <font color="#0000FF">new</font> A();
    a2 = a.func();
    System.out.println(a2.toString());
  }
}

<font color="#0000FF">class</font> A {
  <font color="#0000FF">public</font> int x, y;

  <font color="#0000FF">public</font> A func() {
    <font color="#0000FF">return</font> null;
  };
};
</pre>
</blockquote>
<p>&quot;a2 = a.func();&quot; assigns the <font color="#FF0000"><i><b>Java</b></i></font> 
null object to a2; so &quot;a2.toString()&quot; in the next line will trigger a 
NullPointerException at run time. But the <font color="#FF0000"><i><b>Java</b></i></font> 
compiler doesn't recognize and report this error.</p>
<p>In contrast to this, <font color="#FF0000"><i><b>LavaPE</b></i></font> will 
allow the assignment of <font color="#0000ff"><b>&Oslash; </b></font>(null) to 
an output parameter of a function only if the corresponding formal parameter is 
declared <b>optional</b>. As a consequence, the assignment &quot;a2
<font color="#0000FF"><b>&lt;==</b></font> a.func()&quot; in the main program would be 
rejected at programming time since the assignment target a2 is mandatory. If a2 
were declared optional instead, then &quot;a2.toString()&quot; would now be rejected since 
the use of the optional variable a2 isn't secured by an <font color="#0000FF">
<b><a href="whatsThis/IfdefElse.htm">ifdef</a></b></font> statement or
<font color="#0000FF"><b><a href="whatsThis/IfdefElse.htm">else</a></b></font> 
expression here.</p>
<p>The <b>constructor</b> notions of <b><font color="#FF0000"><i>C++</i></font></b> 
/ <b><font color="#FF0000"><i>Java</i></font></b> / <font color="#FF0000"><b><i>
C# </i></b></font>can only guarantee that an object is initialized <b>anyhow</b>: 
Its member variables are set to default values (numbers to 0 or 0.0, reference 
types to <i>null</i>, etc.) if a 
more meaningful value isn't assigned explicitly. In most cases this won't 
prevent the application from crashing, or, even worse, from silently delivering 
faulty results.</p>
<p>In contrast to this, <font color="#FF0000"><i><b>Lava</b></i></font> informs 
the programmer already at programming time if an initializer is missing or 
an existing initializer fails to initialize all mandatory member variables. The 
enforced distinction between optional 
and mandatory variables is of crucial importance in this context.</p>
<p>Moreover, <font color="#FF0000"><i><b>Lava</b></i></font> provides an 
additional way to prevent meaningless/faulty object initialization: You can add
<b>&quot;<a href="DBC.htm#LavaAA">invariants</a>&quot;</b> to class interfaces and class implementations, i.e., logical 
conditions that must hold true for newly created objects of the respective class 
(and also after any non-read-only method has been applied to such an object).</p>
<hr>
<p><b>Summary:</b> The most fundamental differences between
<font color="#FF0000"><i><b>Lava</b></i></font> and other languages w.r.t 
initialization are: </p>
<ol>
  <li><font color="#FF0000"><i><b>Lava</b></i></font> enforces <b>complete</b> 
  initialization of objects <b>within</b> their respective initializers.</li>
  <li><font color="#FF0000"><i><b>Lava</b></i></font> provides a way to <b>
  safely deal with still unfinished objects</b> in the initialization phase.</li>
  <li><font color="#FF0000"><i><b>Lava</b></i></font> makes sure that <b>
  optional-to-mandatory assignments are always secured</b> by specific 
  constructs <b><a href="whatsThis/IfdefElse.htm">ifdef</a></b> and <b>
  <a href="whatsThis/IfdefElse.htm">else</a></b>.</li>
</ol>
<p><b>This stringent and seamless initialization discipline of
<font color="#FF0000"><i>Lava</i></font> completely and reliably prevents all 
kinds of inadvertent access to uninitialized variables or null objects by purely 
static checks, i.e. already at programming time.</b></p>
<p>Two further kinds of erroneous data access that can be recognized only at run 
time remain in <font color="#FF0000"><i><b>Lava</b></i></font>:</p>
<ol>
  <li>You may catch an exception thrown by class method and subsequently ignore 
  the undefined, null state of output parameters that normally would have 
  well-defined non-null values if the exception had not occurred. Access to such 
  an output parameter will in turn trigger a null-object exception.</li>
  <li>If you (by mistake / prematurely) finalize/zombify objects (see the base 
  class <i>Object </i>of all <font color="#FF0000"><i><b>Lava</b></i></font> 
  classes) and then try to access these, a specific access-to-zombie exception 
  will be thrown.</li>
</ol>
</body>
</html>