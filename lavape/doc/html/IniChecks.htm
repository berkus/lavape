<!DOCTYPE HTML PUBLIC "-//SoftQuad//DTD HoTMetaL PRO 4.0::19971010::extensions to HTML 4.0//EN" "hmpro4.dtd">
<html>
<head>


  
  <meta http-equiv="Content-Language" content="en-us">


  
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1252">


  
  <meta name="GENERATOR" content="Microsoft FrontPage 5.0">


  
  <meta name="ProgId" content="FrontPage.Editor.Document">

  


  
  <title>Initialization checks</title>
  <link rel="STYLESHEET" type="text/css" href="LavaStyles.css">
</head>


<body>


<h2 align="center"><strong>Comprehensive
initialization checks</strong></h2>


<p>Inadvertent use of uninitialized data frequently causes
programs to crash in a way that is hard and time-consuming to
disentangle, which in turn gives rise to immense costs. The attempt to
prevent such situations has therefore been a constitutive design goal
of the <i><font color="#ff0000"><b>Lava</b></font></i>
development. </p>


<p>Our goal was to prevent missing initialization and use of
undefined values by <i>static</i> checks (i.e. at
programming time) wherever possible . However, this required a major
revision of the expressive means for executable code, in comparison
with more traditional wide-spread programming languages. In particular,
we have</p>


<ul>


  <li><a href="RepetComputSamples.htm">replaced
traditional loop constructs</a> by recursive function calls and
bounded quantifiers,</li>


  <li>replaced the traditional view of program variables as
"reusable data containers" by a "<a href="SingleAssigLogSem.htm">single-assignment</a>"
view of variable usage, and</li>


  <li>eliminated parameter passing "by reference" in favor of an
unambiguous distinction between input and output parameters of methods.</li>


  <li>Moreover, expressions that yield an optional result (i.e.,
one that may assume the special value <font color="#0000ff"><b>&Oslash;</b></font>),
cannot be unconditionally assigned to a mandatory variable in <font color="#ff0000"><b><i>Lava</i></b></font>,
but you must either enclose the assignment in an <font color="#0000ff"><b>ifdef</b></font>
statement (which tests whether the optional variable in the
ifdef-condition has a non-null value), or you must use an <font color="#0000ff"><b>else</b></font>
expression or a chain of <font color="#0000ff"><b>else</b></font>
expressions (which finally provides an alternative expression that
yields a non-optional value).</li>


</ul>


<p>More precisely, missing initialization and use of undefined
values have to be prevented with respect to</p>


<ol>


  <li><b>local</b> variables,</li>


  <li><b>member </b>variables of classes, and</li>


  <li><b>output</b> parameters of function calls.</li>


</ol>


<p>(Note that <i>global variables</i> have been
abolished anyway in <font color="#ff0000"><i><b>Lava</b></i></font>
in favor of a purely local, explicit data flow, in order to facilitate
the analysis and comprehension of data flow in complex programs.)</p>


<p>Before you proceed, you should have understood how <font color="#ff0000"> <i><b>Lava</b></i></font>
<a href="RepetComputSamples.htm">replaces traditional loop
constructs</a> and that this implies:</p>


<p><b><span lang="de">F</span>or every
read access to a <font color="#ff0000"><i>Lava</i></font>
variable you can easily find the origin of the current value of this
variable by following the containing program branch in upward direction
(unless the variable is an input variable and therefore a value is
assigned to it already <i>outside</i> this
function).&nbsp;</b></p>


<p>Now let's return to the three kinds of initialization
problems. Note that <i><font color="#ff0000"><b>LavaPE
</b></font></i>1. <a href="EditExec.htm">
shows executable code</a> in separate windows, every function and
initiator body and every invariant in a window of its own, and 2. after
every single editing step in the <font color="#ff0000"><i><b>LavaPE</b></i></font>
structure editors <font color="#ff0000"><i><b>LavaPE</b></i></font>
performs a static check on all the <i><font color="#ff0000"><b>Lava</b></font></i>
code that is currently being presented in any open Window.</p>


<h3>1. Local variables</h3>


<p>Local variables may be introduced in several different ways,
i.e., by several constructs:</p>


<ul>


  <li><font color="#0000ff"><b>declare</b></font>
(just declares new local variables in the usual sense),</li>


  <li><font color="#0000ff"><b>foreach</b></font>
(universal quantifier ranging over some finite set of objects),</li>


  <li><font color="#0000ff"><b>exists</b></font>
(existential quantifier ranging over some finite set of objects),</li>


  <li><font color="#0000ff"><b>select</b></font>
(<font color="#ff0000"><i><b>Lava</b></i></font>
counterpart of the <font color="#ff0000"><i><b>SQL</b></i></font>
select expression),</li>


  <li><font color="#0000ff"><b>type</b></font>
(branches over the run time type of an expression value).</li>


</ul>


<p>which all assign values to the respective local variables that
they introduce, except for the declare construct. So we need to
consider only <i> declared</i> variables.</p>


<p>For every read access to a <i>declared</i> local
variable <font color="#ff0000"><i><b>LavaPE</b></i></font>
checks (statically, = at programming time) if a value is assigned to
this variable above the place of reference in the same
program&nbsp; branch and reports an error otherwise. A somewhat
unusual consequence of this is that a newly declared local variable is
always displayed bold and red initially, marking an error, since there
has not yet been assigned a value to it. </p>


<h3>2. Member variables</h3>


<p>In order to guarantee that all non-optional member variables
of <font color="#ff0000"><i><b>Lava</b></i></font>
objects are properly initialized, <font color="#ff0000"><i><b>Lava</b></i></font>
enforces an unusually stringent initialization discipline<span lang="de">:</span></p>


<ol>


  <li>New <font color="#ff0000"><i><b>Lava</b></i></font>
objects are created using the <font color="#0000ff"><b>new</b></font>
expression, which requires the specification of an "initializer"
associated with the new object's class.</li>


  <li><font color="#ff0000"><i><b>LavaPE</b></i></font>
makes sure (by purely static checks) that every initializer assigns a
value to every non-optional member variable of this class in each of
its branches.</li>


  <li>You can modify these values within the (optional) <font color="#800080"><b>but</b></font> clause
of the <font color="#0000ff"><b>new</b></font>
expression and in this way <i> customize</i> the object
before its completion.</li>


  <li>When a new object leaves the <font color="#0000ff"><b>new</b></font>
construct <font color="#ff0000"><i><b>Lava</b></i></font>
marks it as <i> finished</i>. <font color="#ff0000"><i><b>Lava</b></i></font>
makes sure (by run time checks) that you cannot pass an unfinished
object (from within an initializer or a <font color="#800080"><b>but</b></font>
clause) as an input parameter to any function.<br>


    <br>


This enforces essentially a strict <i>bottom-up construction of
new objects</i> from member objects that have to be constructed
first.</li>


</ol>


<p>Two concessions will (to some degree) soften the "pain" caused
by such a strict bottom-up construction discipline:<i> </i></p>


<p><i>From within an initializer</i></p>


<ul>


  <li>you may use <i>self</i>&nbsp; for calling
a method of self's class: self.method(...), after all non-optional
members of <i>self</i> have been initialized, although the
new object has not yet been marked as <i>finished</i> in
this case.</li>


  <li>you may pass a (not yet completely initialized) <i>self</i>
object as an input parameter to <i>another initializer</i>:
This is inevitably needed if you would like to establish a "backward" <a href="PointersRefCounts.htm">pointer</a> from a member
object to its containing parent object.</li>


</ul>


<p>In more detail, point 2 above means that from every "return
point" of the function body the check follows the respective branch in
upward direction and makes sure that a value is assigned to every
non-optional output parameter in this branch.</p>


<p>A "return point" may be the end of the function body or a <a target="_blank" href="whatsThis/FailSucceed.htm"><font color="#0000ff"><b>succeed</b></font></a>
or <a href="whatsThis/FailSucceed.htm"><font color="#0000ff"><b>fail/throw</b></font></a>
statement. The <a href="whatsThis/FailSucceed.htm"><font color="#0000ff"><b>throw</b></font></a>
statement specifies an expression whose value designates an exception
that is to be thrown.</p>


<p>If a function has output parameters (see below) then it must
not be left without throwing an exception (checked at programming
time). This applies also to initializers of classes.</p>


<p>An exception-throwing <a href="whatsThis/FailSucceed.htm"><font color="#0000ff"><b>throw</b></font></a>
statement is the <i>only</i> way to exit from a class
method or initializer if you cannot assign a value to every
non-optional output parameter. (Checked at programming time.)</p>


<h3>3. Output parameters</h3>


<p><b><font color="#ff0000"><i>Lava</i></font>
doesn't support parameter passing "by reference".</b></p>


<p>In <i> <font color="#ff0000"><b>Lava</b></font></i><b>,</b>
function parameters are either input or output parameters. For
reference parameters it wouldn't be clear whether or not the function
assigns a value to them, whereas a <font color="#ff0000"><i><b>Lava</b></i></font>&nbsp;
function <b>must</b> assign a value to <b>every</b>
non-optional output parameter, and this is checked already at
programming time (= statically).</p>


<p>This is an essential prerequisite for all kinds of <font color="#ff0000"> <i><b>Lava</b></i></font>&nbsp;
initialization checks since only then you can also cover those cases
where a variable is initialized by being an actual output parameter of
a function call.</p>


<p>Assignment of optional to non-optional variables can be
checked only at run time and may cause a null-pointer-exception to
occur.</p>


<p>Like the member initialization checks (see above), the
initialization checks for output parameters are performed at all return
points of the function body.</p>


<p>An exception-throwing <a href="whatsThis/FailSucceed.htm"><font color="#0000ff"><b>throw</b></font></a>
statement is again the <i>only</i> way to exit from a
function if you cannot assign a value to every non-optional output
parameter. (Checked at programming time.)</p>


<p>In this way <font color="#ff0000"><i><b>Lava</b></i></font>
makes sure that undefined outputs cannot be used <i>inadvertently</i>
by the caller of a failing function but only if the resulting exception
is caught and the respective output parameters are used nevertheless
thereafter. </p>


<p>(The worst thing that may happen then is that such an output
is <font color="#0000ff"><b>&Oslash;</b></font>:
then a null-pointer-exception will be thrown in turn, or you use the
output although its value may be meaningless in this case: that's your
own risk and should be avoided without reliable knowledge about the
function's implementation.)</p>


</body>
</html>
