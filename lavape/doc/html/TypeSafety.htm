<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>

  <HEAD>
    <meta http-equiv="Content-Language" content="en-us">
    <TITLE>Type-safety of Lava</TITLE>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
    <META CONTENT="Microsoft FrontPage 5.0" NAME="GENERATOR">
    <meta name="ProgId" content="FrontPage.Editor.Document">
    <LINK HREF="LavaStyles.css" TYPE="text/css" REL="STYLESHEET">
  </HEAD>

  <BODY>

    <H2 ALIGN="center">Static type-safety of <I><FONT COLOR="#ff0000">Lava</FONT></I>,
    related work</H2>

    <P ALIGN="left">Before we can proceed to the outline of a proof of the
      static type-safety of <B><I><FONT COLOR="#ff0000">Lava</FONT></I></B>
      we have to introduce a number of terms, to clarify several pertinent
      notions, and to explain a number of general restrictions that we impose on
      the <A HREF="#compatibility">admissibility of assignments</A> in order to
      achieve <A HREF="#typeSafety">static type-safety</A> for <B><I><FONT COLOR="#ff0000">Lava</FONT></I></B>.</P>

    <H3><B>1.&nbsp; Semantics of &quot;type conformance&quot;</B></H3>

    <P>In the presence of <a href="PatternsFrameworks.htm#multiform">multiform
        types</a> and type parameters the semantics of the statement &quot;object
      x conforms to type Y&quot; has to be reconsidered.</P>

    <P>For instance, if x has been conceived and created as a List[Car], is it
      then admissible to assign x to a variable vList whose type is
      List[Vehicle]?</P>

    <P>On the one hand, if you look only at the <I>structure</I> of x then x
      could clearly be <I>re-interpreted</I> as a List[Vehicle]. In this sense
      x conforms to the type List[Vehicle].</P>

    <P>On the other hand we want to be able to <I>apply all methods</I> of a
      List[Vehicle] to vList . E.g., we would like to append any Vehicle to a
      List[Vehicle]. But if we would append a Bicycle to vList&nbsp; (after
      assigning x to vList) then the value of vList would no longer be a
      List[Car]: an obvious violation of the originally intended type of the
      object x.</P>

    <P><B><A NAME="conformance"></A></B>So we may opt between two
      possibilities:</P>
    <OL>
      <LI>Either we insist that assignment of an object x to a variable vList
        should imply that everything that we may do with a variable of vList's
        type (here List[Vehicle]) may also be applied to vList after the
        assignment of x, </LI>
      <LI>or we allow the assignment of a List[Car] or any other object of a
        type derived from List[Vehicle] to vList but prevent every <I>potentially</I>
        dangerous usage of vList by rigorous <I>static</I> type-checks. </LI>
    </OL>

    <P></P>

    <P>In the first case we could not assign a List[Car] to vList, but the
      message send &quot;vList.add(aBicycle)&quot; would pass the static
      type-check.</P>

    <P ALIGN="justify">In the second case a List[Car] could be assigned to
      vList, &quot;vList.add(aBicycle)&quot; would be rejected by the static
      check, but other interesting message sends would become possible and
      statically acceptable, for instance &quot;vList.f(a1,...,an)&quot;, where &quot;f&quot;
      is any member function whose formal parameter types do <I>not</I> depend
      on any virtual types.</P>

    <P><FONT COLOR="#ff0000"><I><B>Lava</B></I></FONT> does not make a
      one-sided decision in favor of one of these two alternative views but
      leaves the choice to the programmer for every single variable and VT
      declaration. &quot;Subtype-substitution forbidden&quot; is the default in <I>
      <FONT COLOR="#ff0000"><B>Lava<span lang="de"> </span></B></FONT></I>
      (if the sub-type isn't derived in the classical sense but by 
    specialization of virtual types). It may be allowed
      explicitly for individual occurrences of a type T. The name of the type is enclosed in braces: {T}, and
      we speak of the &quot;open&quot; or <B><A NAME="substitutableType"></A>&quot;substitutable
      type&quot; {T}</B> corresponding to the &quot;closed&quot; type T.&nbsp;
      {T} stands in a sense for the <I>set</I> of types that can be c- or
      p-derived from T. Cf. our <A HREF="SubstitutableSamples.htm">substitutable
        type samples</A>.</P>

    <P>The consequences of this refined notion of subtype-substitutability are
      considerable: On the one hand it enables more fine-grained and effective
      static type-checks, since it prohibits potential sources of type errors,
      like &quot;vList.add (aBicycle)&quot; above, that otherwise could be
      detected only at run time.</P>

    <P>On the other hand it complicates the recognition of the admissible
      cases: In the presence of virtual or multiform types and in the absence of
      full subtype-substitutability you typically have to make sure that the
      same &quot;effective pattern context&quot; (<A HREF="#EPC">EPC</A>, see
      below) applies to the source and target side of assignments involving
      virtual or other multiform types (cf. <A HREF="#compatibility">section
        4.1</A>). So you have to <I>determine</I> and to <I>compare</I> the
      EPCs of the affected variables or expressions. In some cases you have to
      check whether an EPC is <I><A HREF="#staticEPC">&quot;static&quot;</A></I>.
      The following sections deal with these problems and end up in a more
      detailed specification of assignment compatibility in <B><I><FONT COLOR="#ff0000">Lava</FONT></I></B>.</P>

    <H3><A NAME="derivationType"></A>2. Classic vs. pattern-induced
    derivations</H3>

    <P><B><A NAME="p-derived"></A>Pattern-induced derivation:</B></P>

    <P>If vt<SUB>1</SUB> is a virtual type of pattern P1 and vt<SUB>2</SUB>
      overrides it in pattern P2 then vt<SUB>2</SUB> is said to be &quot;p-derived&quot;
      from vt<SUB>1</SUB>. Likewise, if the value of vt<SUB>1</SUB> is a
      concrete class A1 and A2 is the corresponding derived class in P2
      then A2 is said to be p-derived from A1.&nbsp; We speak of a
      pattern-induced derivation or p-derivation in this case.</P>

    <P><B><A NAME="c-derived"></A>Classic derivation:</B></P>

    <P>In all other cases, particularly in the absence of virtual types, or in
      the case of class derivations within the same pattern,&nbsp; we speak
      off &quot;classic&quot;, or class, or c-derivations.&nbsp; (A single
      class is also considered to be c-derived from itself.)</P>

    <H3><B>3. Static vs. effective types, pattern contexts</B></H3>

    <P>First, we have to clarify which type restrictions have to be obeyed by
      run time objects in the presence of
      <A HREF="PatternsFrameworks.htm#multiform">multiform</A> types:</P>

    <P>If an object is the value of a constant then its type is determined by
      the type of the constant and the implementation of the language guarantees
      that such an object has the correct type.</P>

    <P>If the object is the output of the built-in object creation expression &quot;<B><FONT COLOR="#0000ff">new</FONT></B>
      <FONT COLOR="#ff0000">&lt;type&gt;</FONT>&quot; then the pattern context
      of the &quot;receiving&quot; variable to which the new object is assigned
      is applied on object creation.</P>

    <P>In all other cases the object can be viewed as the value of some
      variable var (having some declared type):</P>
    <UL>
      <LI>of a local variable (including the special &quot;self/this&quot;
        variable), </LI>
      <LI>or of a formal parameter, </LI>
      <LI>or of a member variable. </LI>
    </UL>

    <P>If the declared type T of a variable var is multiform and depends on
      virtual types then the actual run time meaning of T depends on the actual
      pattern context that has to be applied at run time at this place where var
      is referenced.</P>

    <P>Therefore, we have to lay down which pattern context shall take effect
      in such cases. Let us define several auxiliary notions before:</P>

    <P><B><A NAME="ST"></A>Static type ST:</B></P>

    <P>The static type ST(expr) of an expression occurring in executable <B><I><FONT COLOR="#ff0000">Lava</FONT></I></B>
      code is defined as follows:</P>
    <UL>
      <LI>If expr is a constant then ST(expr) is the obvious standard built-in
        class:<br/>
        <br/>
        Examples: ST(&quot;abc&quot;) = String, ST(1.23) = Float, ST(123) =
        Integer. </LI>
      <LI>If expr is an operator or function expression then ST(expr) is the
        declared formal parameter type of the (unique) output parameter of that
        operator or function that delivers the result of the expression. (Lava
        distinguishes input and output parameters.) </LI>
      <LI>If expr is a formal parameter of a member function or
        <A HREF="Packages.htm#initiator">initiator</A> then ST(expr) is the
        declared type of this formal parameter. </LI>
      <LI>If expr is a member variable (like a.b.c) then ST(expr) is the
        declared type of the respective member (the type of c in this case).
      </LI>
      <LI>If expr is the &quot;self&quot; variable (corresponding to &quot;this&quot;
        in Java/C++) then ST(expr) is the class to which self refers
        statically. </LI>
    </UL>

    <P><B><A NAME="Note1"></A>Note 1: </B>In all cases the ST of an
      expression is reduced to the ST of a variable, viz. the (only) formal
      output parameter of the top-level function or operator of the expression.
      Therefore it is sufficient to consider the static (and also the effective)
      type of variables in the following. The same applies to ET, LPC, EPC, ...
      to be defined below.</P>

    <P><B><A NAME="FV"></A>Final value FV and final virtual value FVV:</B></P>

    <P><FONT SIZE="1"></FONT></P>

    <P>The value of a virtual type may be another virtual type, etc..</P>

    <P>FV(T) = if T is non-virtual then T else FV(VAL(T)) endif.</P>

    <P>FVV(T) = if T is non-virtual then T<br/>
      elsif VAL(T) is non-virtual then T<br/>
      else FVV(VAL(T))<br/>
      endif.</P>

    <P><B><A NAME="NULLPC"></A>NULLPC and<A NAME="LPC"></A> lexical pattern
      context LPC:</B></P>

    <P>The special pattern context NULLPC is used to express that we are
      outside any pattern.</P>

    <P><FONT SIZE="1"></FONT></P>

    <P>The LPC of a class ITF or of an initiator INI is the pattern that
      contains the declaration of ITF or INI (and possibly comprises ITF), or it
      is the &quot;empty&quot; context NULLPC if ITF or INI is not contained in
      any pattern).</P>

    <P>The LPC of any piece of executable code that is contained in a member
      function or invariant of a class ITF is the pattern that contains
      (and possibly comprises) the declaration of ITF (or the &quot;empty&quot;
      context NULLPC if ITF is not contained in any pattern).</P>

    <P>For an initiator INI the LPC is the pattern containing the initiators
      declaration (or the &quot;empty&quot; context NULLPC if INI is not
      contained in any pattern).</P>

    <P><B><A NAME="SELFPC"></A>Self context SELFPC of a member function:</B></P>

    <P>SELFPC is a special symbolic pattern context that stands for the pattern
      context of the &quot;current call object&quot;, i.e., the (run time)
      self/this object of the respective member function to which SELFPC
      pertains. Although it can be effectively determined only at run time it
      plays an important role as a means to express that the types of two
      variables are interpreted using the <I>same</I> pattern context, viz. the
      SELFPC.</P>

    <P><B><A NAME="EPC"></A>Effective pattern context EPC:</B></P>

    <P>A multiform type is a type whose declaration is contained in a pattern.
      It may (but need not) depend on the virtual types of the pattern and thus
      will become a real, effective type only from the perspective of a concrete
      pattern context that is effective in the context of a concrete variable
      reference. We speak of a &quot;static&quot; EPC if it is the LPC of some
      variable or&nbsp; the NULLPC and thus can be determined already at check
      time (rather than run time).</P>

    <P><B>(L) EPC of local variables:</B></P>

    <P>We distinguish three cases as to the nature of the static type ST(var)
      of a local variable var:</P>
    <BLOCKQUOTE>

      <P><B>(L1)</B> ST(var) is <I>non-<A HREF="PatternsFrameworks.htm#multiform">multiform</A>.<br/>
        <br/>
        <A NAME="staticEPC"></A></I>Then <A HREF="#EPC">EPC</A>(var) =
        <A HREF="#NULLPC">NULLPC</A> (&quot;<B>EPC is static</B>&quot;).</P>

      <P><B>(L2) </B>ST(var) is <I>multiform</I> and contained in the
        LPC(var).<br/>
        <br/>
        Then if var is referenced from within a local or member function or 
      invariant<br/>
        then EPC(var) = <A HREF="#SELFPC">SELFPC<br/>
          </A>else EPC(var) = LPC(var) (&quot;<B>EPC is static</B>&quot;).<br/>
        <br/>
        In particular: EPC(self) = SELFPC.</P>

      <P>Note: If var is a local variable of a member function having the
        <A HREF="dialogs/FunctionBox.htm#forceOverride">&quot;callable only from 
      this VT context&quot;</A> attribute then EPC(var) =

<!--
        and ((EPC(var) = <a href="#SELFPC">SELFPC</a> and EPC(expr) = <a href="#LPC">LPC</a>(expr))<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or (EPC(var) = LPC(var) and
      EPC(expr) = SELFPC))-->

        SELFPC = LPC(var) (&quot;<B>EPC is static</B>&quot;).</P>

      <P><B>(L3) </B>ST(var) is <I>multiform</I> and its declaration is not
        contained in the LPC(var).<br/>
        <br/>
        Then EPC(var) = NULLPC (&quot;<B>EPC is static</B>&quot;).</P></BLOCKQUOTE>

    <P><B>(F) </B><B>EPC of formal parameters:</B></P>

    <P>We distinguish four cases as to the nature of the formal parameter var:</P>
    <BLOCKQUOTE>

      <P><B>(F1)</B> var is a formal parameter of a <I>member function</I> of
        some class ITF<br/>
        or of a <I>local function</I> of the implementation of ITF<br/>
        and its declared type ST(var) is contained in LPC(ITF).</P>

      <P>Then EPC(var) = <A HREF="#SELFPC">SELFPC</A>.</P><FONT SIZE="1"></FONT>

      <P>Note 1: From the &quot;interior&quot; perspective of a function, we
        cannot say any more about SELFPC. However, from the caller's point of
        view EPC(var) = SELFPC is the same as the EPC(callvar.mem) of any member
        variable mem of the variable callvar with that the function is called.</P>

      <P ALIGN="justify">Note 2: If var is a formal parameter of a member
        function having the &quot;<A HREF="dialogs/FunctionBox.htm#forceOverride">callable 
      only from this VT context</A>&quot; attribute then SELFPC = EPC(var) =
        LPC(var) (&quot;<B>EPC is static</B>&quot;).</P>

      <P><B>(F2)</B> ST(var) is <I>not</I> contained in LPC(ITF).<br/>
        <br/>
        Then EPC(var) = NULLPC (&quot;<B>EPC is static</B>&quot;).</P>

      <P><B>(F3)</B> var is a formal parameter of an initiator INI<br/>
        and its declared type ST(var) <I>is contained</I> in LPC(INI).<br/>
        <br/>
        Then EPC(var) = LPC(INI) (&quot;<B>EPC is static</B>&quot;).</P>

      <P><B>(F4) </B>ST(var) <I>is not contained</I> in LPC(INI)<br/>
        <br/>
        Then EPC(var) = NULLPC (&quot;<B>EPC is static</B>&quot;).</P></BLOCKQUOTE>

    <P><B>(M) </B><B>EPC of member variables:</B></P>

    <P>Assume that var is a member variable a<SUB>1</SUB><B>.</B>a<SUB>2</SUB><B>.
      ... .</B>a<SUB>n</SUB>&nbsp; (with n&gt;1). Then a<SUB>1</SUB> is a
      local variable or a formal parameter. (Note that a member x of the &quot;self/this&quot;
      object is designated by &quot;self<B>.</B>x&quot; in <B><I><FONT COLOR="#ff0000">Lava</FONT></I></B>.)
      The EPC of such a variable is then defined recursively as follows:</P>
    <BLOCKQUOTE>

      <P>If EPC(a<SUB>1</SUB><B>. ... .</B>a<SUB>n-1</SUB>) = NULLPC<br/>
        then EPC(a<SUB>1</SUB><B>. ... .</B>a<SUB>n</SUB>) = LPC(ST(a<SUB>n-1</SUB>))
        (&quot;<B>EPC is static</B>&quot;)<br/>
        else if ST(a<SUB>n</SUB>) is contained in EPC(a<SUB>1</SUB><B>. ... .</B>a<SUB>n-1</SUB>)<br/>
        then EPC(a<SUB>1</SUB><B>. ... .</B>a<SUB>n</SUB>) = EPC(a<SUB>1</SUB><B>.
        ... .</B>a<SUB>n-1</SUB>),<br/>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and EPC(a<SUB>1</SUB><B>.
        ... .</B>a<SUB>n</SUB>) <B>is</B> <B>static</B> if EPC(a<SUB>1</SUB><B>.
        ... .</B>a<SUB>n-1</SUB>) is static<br/>
        else EPC(a<SUB>1</SUB><B>. ... .</B>a<SUB>n</SUB>) = NULLPC (&quot;<B>EPC
        is static</B>&quot;).</P></BLOCKQUOTE>

    <P><B><A NAME="MVT"></A>Mapped virtual type MVT:</B></P>

    <P>The function MVT maps a given virtual type vt<SUB>1</SUB> contained in
      some pattern&nbsp;dp<SUB>1</SUB> to its overridden counterpart vt<SUB>2</SUB>
      in a pattern dp<SUB>2</SUB> that has been derived from dp1:<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      MVT(vt<SUB>1</SUB>,dp<SUB>2</SUB>)&nbsp; = vt<SUB>2</SUB>,<br/>
      provided that vt<SUB>1</SUB> has been overridden by vt<SUB>2</SUB> in dp<SUB>2</SUB>;
      otherwise we have<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      MVT(vt<SUB>1</SUB>,dp<SUB>2</SUB>) = vt<SUB>1</SUB>.</P>

    <P>If the multiform but non-virtual type pt is contained in pattern dp<SUB>1</SUB>
      then MVT(pt,dp<SUB>2</SUB>) causes pt and the types of all its member
      variables to be interpreted in the context of pattern dp2: The effect on
      the type of a member variable is the same as if we had a variable a<SUB>1</SUB>
      of type pt in pattern context EPC(a1) = dp2 and would interpret the type
      of a member a<SUB>1</SUB><B>. ... .</B>a<SUB>n</SUB><SUB> </SUB>in the
      context EPC(a<SUB>1</SUB><B>. ... .</B>a<SUB>n-1</SUB>). Note that
      MVT(pt,dp2) need not be declared explicitly in dp2 (by overriding pt) but
      may be an unnamed, implicit type.</P>

    <P>For formal reasons we define MVT also for uniform types npt and
      arbitrary patterns p as follows:<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      MVT(npt,p) = npt.</P>

    <P>Note: If the value of a virtual type vt<SUB>1 </SUB>is again a virtual
      type vt<SUB>2</SUB> and vt<SUB>1</SUB> has been overridden by vt<SUB>1m</SUB>
      in a derived pattern dp then the <B><I><FONT COLOR="#ff0000">Lava</FONT></I></B>
      override mechanism automatically guarantees that</P>
    <UL>
      <LI>if&nbsp; vt<SUB>2</SUB> has also been overridden in dp (by vt<SUB>2m</SUB>,
        say) then VAL(vt<SUB>1m</SUB>) = vt<SUB>2m<br/>
        </SUB>else VAL(vt<SUB>1m</SUB>) = vt<SUB>2</SUB>. </LI>
    </UL>

    <P>This in turn enforces the validity of the following equation in this
      case:</P>

    <P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      MVT(VAL(vt<SUB>1</SUB>),dp) = MVT(VAL(MVT(vt<SUB>1</SUB>,dp)),dp).</P>

    <P>In other words: The order in which you perform the following operations
      does not matter:</P>

    <P>(A) You first proceed to the value of vt and then map the latter to the
      derived pattern dp.</P>

    <P>(B) You first map vt to the derived pattern dp, then proceed to the
      value of the mapped VT, and finally you map it to the derived pattern, if
      it has also been overridden. (If not, then the final MVT operation has no
      effect.)</P>

    <P><B><A NAME="RT"></A>The effective type ET:</B></P>

    <P>If the static type <A HREF="#ST">ST</A>(var) of a variable var is not
      multiform then&nbsp; ET(var) = ST(var).</P>

    <P>If ST(var) is multiform but non-virtual then ET(var) =
      MVT(ST(var),EPC(var)).</P>

    <P>If ST(var) is virtual then we have to compute its final virtual value
      FVV, which may require a further mapping into EPC(var), before you can
      take the final value of the result. These three operations can be combined
      into a single formula as follows:</P>

    <P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      ET(var) = FV(MVT(FVV(ST(var)),EPC(var)))</P>

    <P>which also applies to the two before-mentioned cases since MVT, FVV, and
      FV have been properly defined for the &quot;degenerate&quot; cases of
      uniform and non-virtual types.</P>

    <P>ET(self) is the effective type of the variable &quot;callvar&quot; with
      that the function containing the &quot;self&quot; reference has been
      called.</P>

    <P><B>Note 1:</B> It can be concluded from sections 2.3 and 3.2.2 that the
      effective type ET(self) of &quot;self&quot; can in fact be computed from
      ST(self) in the same way as described above for all other kinds of
      variables. (The decisive argument is that if ST(self) is multiform then in
      pattern EPC(self) there is essentially no other type than
      MVT(ST(self),EPC(self)) that qualifies as the type of callvar).</P>

    <P><B>Note 2:</B> If EPC(var) = NULLPC then ET(var) = FV(ST(var)), i.e.,
      the declared values of the virtual types apply.</P>

    <P><B>Note 3:</B> If a concrete object obj is created using the &quot;<B><FONT COLOR="#0000ff">new</FONT></B>
      &lt;type&gt;&quot; expression then ET(obj) = type. If obj is the value of
      a constant then ET(obj) is the type of the constant, for instance Integer
      for the constant 123.</P>

    <H3><A NAME="compatibility"></A>4. Type-Checking Rules for the
    Admissibility of Assignments<FONT FACE="TIMES" SIZE="2"> </FONT></H3>

    <P ALIGN="justify">Type-checking has to do with assignments. Parameter
      passing to a function or from a function must also be considered as a
      special kind of assignment: An actual input parameter is assigned to the
      corresponding formal input parameter, a formal output parameter is
      assigned to a receiving variable.</P>

    <P ALIGN="justify">In the following section 4.1 we assume that all types are &quot;closed&quot;,
      non-substitutable types. The case of &quot;open&quot;,
      <A HREF="#substitutableType">substitutable</A> types is treated in
      section 4.2.</P>

    <P>The <A HREF="PatternsFrameworks.htm#VTvalue">value</A> of a virtual
      type may be another virtual type, which again has a value, etc.. In the
      following the term &quot;indirect value&quot; designates any value that
      one encounters when backtracking this sequence of values.</P>

    <P>Note that parameter passing to a function or from a function must also
      be considered as a special kind of assignments: An actual input parameter
      is assigned to the corresponding formal input parameter, a formal output
      parameter is assigned to a receiving variable.</P>

    <H3><a name="section_4_1"></a>4.1 Type-Checking in the Absence of Subtype-Substitutability</H3>

    <P><B>An expression expr may be assigned to a variable var if</B> </P>
    <OL>
      <LI>Both ST(var) and ST(expr) are non-virtual<br/>
        <br/>
        and ST(expr) is c-derived from ST(var)<br/>
        and if both are multiform then EPC(var ) = EPC(expr), </LI>
      <LI><B><A NAME="secondCase"></A>or</B> both&nbsp; are virtual types<br/>
        <br/>
        and <A HREF="#EPC">EPC</A>(var ) = EPC(expr)<br/>
        and they are equal,&nbsp;<br/>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or one of them overrides the other
        (directly or indirectly),<br/>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or one is the immediate<br/>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or an
        indirect value of the other<br/>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or of an
        override of the other, </LI>
      <LI><B>or</B> one of ST(var) and ST(expr) is virtual and the other is
        non-virtual<br/>
        <br/>
        and the EPC of the virtual side is &quot;static&quot; (see the
        definition of EPC above)<br/>
        and (if the ST of the non-virtual side is multiform then EPC(var ) =
        EPC(expr) )<br/>
        and ET(expr) is c-derived from ET(var). </LI>
    </OL>

    <P><A NAME="compAtCheckTime"></A>In the third case ET(expr) and ET(var)
      are statically computable (at &quot;check time&quot;) since the EPCs of
      both sides are static then, and thus we can check statically whether
      ET(expr) is c-derived from ET(var). Considering this, we may state that
      all of the foregoing three conditions can be evaluated statically.</P>

    <P>The third case covers in particular situations&nbsp;where a virtual type
      with &quot;closed bound&quot; (<A HREF="#TT">[16]</A> p. 189) would be
      definitely undesirable whereas the &quot;<A HREF="dialogs/FunctionBox.htm#forceOverride">callable 
    only from this VT context</A>&quot;
      mechanism of <B><I><FONT COLOR="#ff0000">Lava</FONT></I></B> is still
      applicable and acceptable.</P>

    <P>For simplicity's sake we have omitted the trivial rule that every type
      is assignment compatible with the common base type &quot;Object&quot; of
      all types.</P>

    <P>The <B><I><FONT COLOR="#ff0000">Lava</FONT></I></B> programming
      environment <B><I><FONT COLOR="#ff0000">LavaPE</FONT></I></B> makes it
      very easy for the programmer to obey these rules since references to types
      are not keyed in as textual identifiers in <B><I><FONT COLOR="#ff0000">Lava</FONT></I></B>
      but selected from proper type-selection combo-boxes whose contents would
      depend on the current insertion point. These combo-boxes simply will not
      offer inadmissible types for selection in the foregoing situations.</P>

    <H3>4.2 Type-Checking in the Presence of &quot;Substitutable&quot; Types</H3>

    <P ALIGN="justify">Again we consider the question whether an expression expr 
    may be assigned to a variable var, but this time we assume that the type of 
    at least one of these is declared &quot;substitutable&quot; explicitly.</P>

    <P ALIGN="justify">An expression expr may be assigned to a variable var if</P>
    <OL TYPE="a">
      <LI>ST(var) = {Tvar} is substitutable&nbsp;<br/>
        and ST(expr) is some Texpr or {Texpr}&nbsp;<br/>
        and Texpr is c-derived or p-derived from Tvar. </LI>
    </OL>
    <BLOCKQUOTE>

      <P ALIGN="justify">The safeness of this kind of assignments is obvious.
        The actual problem is,</P></BLOCKQUOTE>
    <UL>
      <LI>how to proceed if a substitutable type is encountered in the middle
        of the context-tracking process for some variable var = a<SUB>1. </SUB>...
        .a<SUB>n</SUB>, and </LI>
      <LI>how to check message sends &quot;var.func(ap<SUB>1</SUB>,...,ap<SUB>n</SUB>)&quot;
        if var's type is substitutable: </LI>
    </UL>
    <OL TYPE="a" START="2">
      <LI>The first problem may cause a premature termination of the
        context-tracking process for var, and thus EPC(var) counts as &quot;undefined&quot;.
        In this case our static checks have to reject all assignments whose
        left-hand or right-hand side is var, and for a message send &quot;var.func(ap<SUB>1</SUB>,...,ap<SUB>n</SUB>)&quot;
        the assignment compatibility of actual and formal parameters cannot be
        assessed, either, and must yield a negative result therefore, except if
        actual and formal parameter types are declared outside any pattern
        context: then the rules of section 4.1 may be applied. </LI>
      <LI>If the first problem does not occur but var's type {Tvar} is
        substitutable then it is still impossible to statically determine a
        fixed call context for the above message send. Since we insist on purely
        static type-checking, we simply reject such a message send if its actual
        or formal parameter types are contained in the pattern context P of Tvar or
        in a context derived from P. Otherwise we attempt to apply rule (a)
        above or the rules of section 4.1. </LI>
    </OL>

    <H3><A NAME="typeSafety"></A>5. Semantics of &quot;type-safety&quot;</H3>

    <P>Type-safety has to do with assignments. An assignment has a left-hand
      side, which is a variable, and a right-hand side, which may be a variable,
      a constant, or an operator or function expression.</P>

    <P>Now the static type-safety of <FONT COLOR="#ff0000"><B><I>Lava</I></B></FONT>
      can be stated as follows:&nbsp;</P>
    <UL>
      <LI>If at run time a <B><I><FONT COLOR="#ff0000">Lava</FONT></I></B>
        program assigns an object obj to a variable var then we can be sure that
        obj conforms to ET(var), i.e., the run time type RT(obj) is equal to or
        c-derived from ET(var), </LI>
      <LI>provided one of the alternative static <A HREF="#compatibility">assignment
          admissibility rules</A> of section 4.1 is fulfilled. </LI>
    </UL>

    <H3><A NAME="proof"></A>6. Proof outline: <I><FONT COLOR="#ff0000">Lava</FONT>
    </I>is statically type-safe</H3>

    <P>The places where the run time system injects objects into the program
      must be made type-safe by the run time system: Constants, built-in
      creation, copy, and cloning functions, other built-in operators and
      functions, component interfaces. Likewise, all cases of missing
      initialization of variables or exceptional operations leading to undefined
      results have to be detected by the run time system and will never cause
      type violations.</P>

    <P>Now assume that we had a &quot;bad&quot;, non-type-safe <B><I><FONT COLOR="#ff0000">Lava</FONT></I></B>
      program that performs a &quot;bad&quot; assignment A. If the right-hand
      side of A is ok, i.e., the object delivered by the right-hand side
      expression conforms to the type of that expression, then we stay with A.
      Otherwise we can prove that there yet must exist &quot;bad&quot;
      assignment whose right-hand side is ok:</P>

    <P>We backtrack the data flow, beginning with A, by walking from the
      left-hand side (lhs) to the right-hand side (rhs) of A and of all
      predecessor assignments until we arrive at a &quot;bad&quot; assignment
      whose rhs is ok.</P>

    <P>This is guaranteed to occur: Either we arrive at a &quot;good&quot;
      assignment after a &quot;bad&quot; assignment; then both of its sides are
      ok and its lhs is the rhs of its predecessor assignment in that sequence,
      which thus would be a &quot;bad&quot; assignment whose rhs is ok.</P>

    <P>Or we never arrive at a &quot;good&quot; assignment. But then we must
      finally end up after finitely many steps at a &quot;bad&quot; assignment
      whose rhs is a constant, built-in creation function, etc. (see above),
      which we have assumed to be ok.</P>

    <P>So in any case we can find a &quot;bad&quot; assignment A from an
      expression expr to a variable var whose right-hand side expr is ok. The
      run time type of the result object obj of expr conforms to the effective
      type ET(expr) since the rhs of our &quot;bad&quot; assignment is ok. In
      the following it suffices to prove that ET(expr) is c-derived from
      ET(var). We may conclude then that the run time type RT(obj) conforms also
      to ET(var).</P>

    <P>Since A must nevertheless conform to the assignment compatibility rules
      of section 4.1 we can distinguish the following cases:</P>

    <P><B>Case 1:</B> Both ST(var) and ST(expr) are non-virtual<br/>
      and ST(expr) is c-derived from ST(var)<br/>
      and if both are multiform then EPC(var ) = EPC(expr). </P>

    <P><B>(A)</B> Assume that <I>not</I> both of ST(var) and ST(expr) are
      multiform. </P>

    <P>If ST(var) were multiform then ST(expr) would be multiform, too, since
      c-derivation from a multiform base type is only allowed within the
      containing pattern and thus yields a multiform derived type. So we may
      conclude that ST(var) is uniform. Hence ET(var) = ST(var). </P>

    <P>If ST(expr) is uniform, too, then ET(expr) = ST(expr) and thus ET(expr)
      is c-derived from ET(var). </P>

    <P>If ST(expr) is multiform then ET(expr) arises from ST(expr) by replacing
      the values of certain virtual types on which ST(expr) depends.
      Nevertheless the result ET(expr) of this mapping still &quot;contains&quot;
      ST(var) as a base type. Hence ET(expr) is c-derived from ST(var) =
      ET(var), what had to be proven. </P>

    <P><B>(B)</B> Assume both ST(var) and ST(expr) are multiform (but
      non-virtual). </P>

    <P>Then EPC(var) = EPC(expr). ST(expr) is c-derived from ST(var) and
      therefore just adds a number of additional members to ST(var). ET(var)
      arises from ST(var) by replacing the values of certain virtual types on
      which ST(var) depends. Transition from ST(expr) to ET(expr) applies the
      same replacements to the ST(var) base and retains the additional features
      of ST(expr). So ET(expr) is still c-derived from ET(var),. </P>

    <P><B>Case 2:</B> Both&nbsp;ST(var) and ST(expr) are virtual<br/>
      and EPC(var ) = EPC(expr)<br/>
      and they are equal, or one of them overrides the other (directly or
      indirectly), or one is the immediate or an indirect value of the other or
      of an override of the other. </P>

    <P><B>(A)</B> Assume ST(var) = ST(expr): </P>

    <P>In this case EPC(var ) = EPC(expr) implies that ET(var) = ET(expr), and
      consequently ET(expr) is c-derived from ET(var). </P>

    <P><B>(B)</B> Assume that ST(var) overrides ST(expr) directly or
      indirectly: </P>

    <P>(An analogous argumentation applies to the opposite case.) </P>

    <P>Then we may conclude from EPC(var ) = EPC(expr)&nbsp; that
      MVT(ST(var),EPC(var)) = MVT(ST(expr),EPC(expr)) is true, i.e., ST(var) and
      ST(expr) are mapped to the same virtual type in EPC(var). Consequently
      their effective types ET(var) and ET(expr) are equal, too.&nbsp; </P>

    <P><B>(C)</B> Assume that ST(var) is the immediate or an indirect value of
      ST(expr) or of an override of ST(expr): </P>

    <P>(An analogous argumentation applies to the opposite case.) </P>

    <P>A quite similar argumentation as in (B) leads us to the conclusion that
      MVT(FVV(ST(var)),EPC(var)) = MVT(FVV(ST(expr)),EPC(expr)), and hence
      ET(var) = ET(expr),. </P>

    <P><B>Case 3:</B> One of ST(var) and ST(expr) is virtual and the other is
      non-virtual<br/>
      and the EPC of the virtual side is &quot;static&quot; (see the
      <A HREF="#EPC">definition of EPC</A> above)<br/>
      and if the non-virtual side is multiform then EPC(var ) = EPC(expr)<br/>
      and ET(expr) is c-derived from ET(var). </P>

    <P>In this case nothing remains to be proven, in fact, but what matters is
      the observation is that both ET(var) and ET(expr)
      <A HREF="#compAtCheckTime">can be computed at check time</A> under these
      conditions. </P>

    <H3><A NAME="relatedWork"></A>7. Related Work</H3>

    <P>Since a few years there is a broader discussion on &quot;generic and
      virtual types&quot; and particularly on desirable <FONT COLOR="#ff0000"><I><B>Java</B></I></FONT>
      enhancements concerning genericity. A particular outcome of this
      discussion was a notion of &quot;virtual type&quot; that is based on the
      following idea: A virtual type is described by a special kind of member
      variables of classes. The value of such a virtual type member is a
      concrete (conventional) type or defined (in more recent approaches like
      <A HREF="#TT">[16]</A> below) by a recursive type expression that may
      involve this same or other virtual types.</P>

    <P>In order to reference such a virtual type in variable declarations you
      need an object of the respective class containing this virtual type field.
      (In most cases the &quot;this&quot; object is used, which may be omitted
      usually, or the examples make use of &quot;inner classes&quot; in the
      specific sense of <FONT COLOR="#ff0000"><B><I>Java</I></B></FONT> and
      thus inherit the virtual type fields of the containing &quot;outer&quot;
      class.)</P>

    <P><FONT COLOR="#ff0000"><I><B>Lava</B></I></FONT> takes a rather
      different approach, primarily for the following reasons:</P>
    <OL>
      <LI>We felt that the type of a variable should be declared in a more
        static way. It is a rather crude disruption of tradition that should be
        avoided if you have to provide some executable code and to produce some
        object having virtual type fields before you can declare the types of
        further variables of your actual application. </LI>
      <LI>We preferred to maintain the strict traditional view on &quot;type
        conformance&quot; (type = class describing the mandatory attributes
        and methods that may be applied to <I>every</I> object conforming to
        that type), while other proposals, for instance <A HREF="#TT">[16]</A>,
        seem to allow assignments from List[Car] to List[Vehicle]; cf.
        <A HREF="#conformance">section 1</A>.&nbsp; </LI>
      <LI>The special relation of inner classes to their container classes in
        <FONT COLOR="#ff0000"><I><B>Java</B></I></FONT> has been invented in
        the likewise special context of the revised event handling / callback
        concept of <FONT COLOR="#ff0000"><B><I>Java</I></B></FONT> 1.1. We
        have a different callback concept in <FONT COLOR="#ff0000"><I><B>Lava</B></I></FONT>
        that doesn't need inner classes in the sense of <FONT COLOR="#ff0000"><I><B>Java</B></I></FONT>.<br/>
        <br/>
        Packages with virtual type parameters appeared to be more appropriate
        for the representation of patterns consisting of several interrelated
        classes (like model/view frameworks). </LI>
      <LI>It is a very undesirable restriction if you have to declare a
        <A HREF="PatternsFrameworks.htm#bound">virtual type's bound</A> to be &quot;closed&quot;
        (= non-overridable) in order to insert a constant or a newly created
        object into a structure that expects this object to be of the respective
        virtual type.<br/>
        <br/>
        Example: You want to append a &quot;new String&quot; object to a
        List[String]. The List[String] pattern should nevertheless remain open
        for further specializations of the String parameter. </LI>
    </OL>

    <P>The most recent developments w.r.t. <FONT COLOR="#ff0000"><I><B>Java</B></I></FONT>
      genericity enhancements (cf. [3], [6]) seems to center exclusively around
      modernized versions of &quot;parametric polymorphism&quot; (a successor
      concept to C++ templates in a sense), which, unlike virtual types, is not
      particularly suited for coping with collective specialization of families
      of interrelated classes.&nbsp;</P>

    <P>In our section on <A HREF="CounterSamples.htm">counter-counterexamples</A>
      we show that the examples in reference [4] below that are presented there
      in order to demonstrate inherent flaws of virtual types don't cause any
      problems in <B><I><FONT COLOR="#ff0000">Lava</FONT></I></B>. Therefore&nbsp;
      we are still convinced that virtual types represent the more advantageous,
      promising and modern approach to genericity in object-oriented languages.</P>

    <P><B>References</B></P>
    <OL>
      <LI>Agesen, O., Freund, S., Mitchell, J.: Adding parameterized types to
        Java. Proceedings OOPSLA'97. </LI>
      <LI>Bank, J.A., Myers, A.C., Liskov, B.: Parameterized Types for Java,
        Proceedings POPL.97, p.132-145. </LI>
      <LI>Bracha, G., Odersky, M., Stoutamire, D., Wadler, Ph.: Making the
        future safe for the past: Adding Genericity to the Java<SUP>TM</SUP>
        Programming Language. Proceedings OOPSLA'98. </LI>
      <LI><A NAME="BOW"></A>Bruce, K.B., Odersky, M., Wadler, Ph.: A
        Statically Safe Alternative to Virtual Types. Proceedings ECOOP.98,
        p.523-549. </LI>
      <LI>Bruce, K.B., Vanderwaart, J.: Semantics-Driven Language Design:
        Statically Type-Safe Virtual Types in Object-Oriented Languages.
        Proceedings MFPS'99. </LI>
      <LI>Cartwright, R., Steele, G.J.: Compatible Genericity with Run-time
        Types for the Java<SUP>TM</SUP> Programming Language. Proceedings
        OOPSLA'98. </LI>
      <LI>Chambers, C., Harrison, B., Vlissides, J.: A Debate on Language and
        Tool Support for Design Patterns. Proceedings POPL.00, p.277-289. </LI>
      <LI><A NAME="GOF"></A>Gamma, E., Helm, R., Johnson, R., Vlissides, J.:
        Design Patterns: Elements of Reusable Object-Oriented Software.
        Addison-Wesley, 1995, ISBN 0201633612. </LI>
      <LI>Gosling, J., Joy, B., Steele, G.: Java Language Specification. Sun
        Microsystems, 1996, ISBN 0201634511. </LI>
      <LI>Java: http://www.javasoft.com. </LI>
      <LI>Lava: http://lavape.sourceforge.net/Lava. </LI>
      <LI><a name="Eiffel"></a>Meyer, B.: Eiffel: The Language. Prentice Hall Europe, 1992, ISBN
        0132479257. </LI>
      <LI>Odersky, M., Wadler, Ph.: Pizza into Java: Translating Theory into
        Praxis. Proceedings POPL.97, p.146-159. </LI>
      <LI>Stroustrup, B.: The C++ Programming Language, Special Edition.
        Addison-Wesley, 2000, ISBN 0201700735. </LI>
      <LI>Thorup, K.K.: Genericity in Java with Virtual Types. Proceedings
        ECOOP.97, p.44-471. </LI>
      <LI><A NAME="TT"></A>Thorup, K.K., Torgersen, M.: Unifying Genericity
        (Combining the Benefits of Virtual Types and Parameterized Classes).
        Proceedings ECOOP.99, p.186-204. </LI>
      <LI>Torgersen, M.: Virtual Types are Statically Safe. 5th Workshop on
        Foundations of Object-Oriented Languages, San Diego, CA, January 1998.
      </LI>
    </OL>
  </BODY>
</HTML>