<!DOCTYPE HTML PUBLIC "-//SoftQuad//DTD HoTMetaL PRO 4.0::19971010::extensions to HTML 4.0//EN"
 "hmpro4.dtd">

<HTML>
  
  <HEAD>
    <meta http-equiv="Content-Language" content="en-us">
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
    <META NAME="Author" CONTENT="Klaus D. G&uuml;nther">
    <META NAME="GENERATOR" CONTENT="Microsoft FrontPage 5.0">
    <meta name="ProgId" content="FrontPage.Editor.Document">
    <TITLE>Principal orienation of Lava</TITLE>
    <LINK REL="STYLESHEET" TYPE="text/css" HREF="LavaStyles.css">
  </HEAD>
  
  <BODY>
    
    <h2 ALIGN="CENTER">Principal orientation of <font color="#FF0000"><i><b>
    Lava</b></i></font></h2>
    
    <p>There are two rather different principal orientations or philosophies to 
    which a programming language may adhere, and it is primarily a matter of 
    taste and personal experiences which of these <i>you</i> prefer. They can be 
    characterized by two basic, conflicting notions or ideas which they would 
    particularly emphasize:</p>
    <ul>
      <li><b>Clarity</b></li>
      <li><b>Flexibility</b></li>
    </ul>
    <h3>Clarity-centric languages would emphasize ...</h3>
    <ul>
      <li>a minimum number of different, <font color="#FF0000">orthogonal language constructs</font>.</li>
      <li>the <font color="#FF0000">comprehensibility</font> of programs (also 
      for other programmers), which is a necessary precondition for</li>
      <li><font color="#FF0000">ease and low cost of maintenance</font> and 
      change, adaptability to new, changed requirements.</li>
      <li>a <font color="#FF0000">clear program structure in the small and in 
      the large</font>, rather than &quot;spaghetti programs&quot; (i.e. a control flow 
      jungle) or &quot;tortellini programs&quot; (i.e. an unstructured hodgepodge of 
      numerous small pieces, e.g. methods of classes, lacking a proper structure 
      in the large).</li>
      <li>the static nature of the language and <font color="#FF0000">partly redundant 
      declarations</font> that reveal the programmers intentions how and to 
      which end the various program entities shall be used; these enable not 
      only</li>
      <li><font color="#FF0000">comprehensive static checks</font>, particularly 
      initialization checks, prevention of programming errors at the earliest 
      possible moment, but make it also easier to</li>
      <li><font color="#FF0000">understand the role</font> that the respective 
      program entities play in their respective context.</li>
      <li>a <font color="#FF0000">more standardized structure and representation</font> 
      of programs, independent of the personal taste and habits of different 
      authors.</li>
    </ul>
    <h3>Flexibility-centric languages would emphasize ...</h3>
    <ul>
      <li>the <font color="#FF0000">utmost freedom of the programmer</font> in which order to proceed, or 
      where to do what, or which things to put together or to separate,</li>
      <li><font color="#FF0000">&quot;expressiveness&quot;</font>: a rich repertoire of specialized, very concise, 
      perhaps adaptable expressive means for special situations,</li>
      <li>allowing also access to <font color="#FF0000">lower-level features</font>;</li>
      <li>the <font color="#FF0000">dynamic nature of the language</font>, for instance dynamic creation of 
      new classes, fields, or methods at run time, </li>
      <li><font color="#FF0000">extensibility</font> of the language, macro and template support,</li>
      <li><font color="#FF0000">run time checks</font>; static checks only where possible in spite of the 
      flexibility and dynamic nature of the language.</li>
    </ul>
    <h3>Clarity and flexibility certainly aren't completely incompatible, but ...</h3>
    <p>experience shows that most programming languages can be easily classified 
    as putting more emphasis on &quot;freedom&quot; or more emphasis on &quot;discipline&quot;. 
    Admittedly and understandably, most programmers would prefer freedom. But 
    today a program is no longer a dialog between a single programmer and a 
    computer. To an increasing degree programs are <i>joint</i> intellectual 
    property of a <i>group</i> of programmers whose membership may fequently 
    change. </p>
    <p>Therefore it is of increasing importance that a program can be easily 
    understood not only by its author but also by other programmers having 
    different preferences and habits. Consequently ...</p>
    <h3> <b><i>
    <font color="#FF0000">Lava</font></i> is  oriented towards the 
    clarity goal ...</b></h3>
    <p>since we believe that comprehensibility, ease of maintenance and 
    modification by different programmers, a clear and natural,
    <font color="#FF0000">more standardized 
    structure and representation</font> of programs in the small and in the large and comprehensive support by 
    structure-oriented programming tools, static checks and early error 
    reporting are those things that we need most urgently today. </p>
    <p>They should have priority over tricky, sophisticated, hard to understand, 
    specialized or highly dynamic features, personal programming styles, and 
    superficial simplicity/shortness of expressions whose actual  
    effect is highly dependent on the respective static or even run time context 
    and can be understood only after an arduous analysis.</p>
    <h3><b>See also</b></h3>
    <p><strong style="font-weight: 400"><a href="IniChecks.htm">Complete
static initialization checks</a></strong></p>
    <p><a href="OOPS-MIMM.htm">Object-Oriented Problem Separation</a></p>
    <p><a href="OOanalysis.htm">Using <font color="#FF0000"><i>Lava</i></font>
    for object-oriented analysis and design</a></p>
    </BODY>
</HTML>