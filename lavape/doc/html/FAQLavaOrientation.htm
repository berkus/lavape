<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Principal orienation of Lava</title>
  <meta http-equiv="Content-Style-Type" content="text/css"/>
  <link rel="STYLESHEET" type="text/css" href="LavaStyles.css" />
  <style type="text/css" xml:space="preserve">
/*<![CDATA[*/
  h3.c3 {font-weight: bold}
  h2.c2 {text-align: center}
  em.c1 {font-weight: bold; color: Red}
  /*]]>*/
      .style1
      {
          color: #FF0000;
          font-style: italic;
      }
  </style>
</head>

<body>
  <h2 class="c2">Principal orientation of <em class="c1">Lava</em></h2>

  <p>There are two rather different principal orientations or philosophies to which a programming language may adhere, and it is primarily a matter of taste and personal experiences which of these <em>you</em> prefer. They can be characterized by two basic, conflicting notions or ideas which they would particularly emphasize:</p>

  <ul>
    <li><strong>Clarity</strong></li>

    <li><strong>Flexibility</strong></li>
  </ul>

  <h3>Clarity-centric languages would emphasize ...</h3>

  <ul>
    <li>a minimum number of different, orthogonal language constructs.</li>

    <li>the comprehensibility of programs (also for other programmers), which is a necessary precondition for</li>

    <li>ease and low cost of maintenance and change, adaptability to new, changed requirements.</li>

    <li>a clear program structure in the small and in the large, rather than &quot;spaghetti programs&quot; (i.e. a control flow jungle) or &quot;tortellini programs&quot; (i.e. an unstructured hodgepodge of numerous small pieces, e.g. methods of classes, lacking a proper structure in the large).</li>

    <li>the static nature of the language and partly redundant declarations that reveal the programmers intentions how and to which end the various program entities shall be used; these enable not only</li>

    <li>comprehensive static checks, particularly initialization checks, prevention of programming errors at the earliest possible moment, but make it also easier to</li>

    <li>understand the role that the respective program entities play in their respective context.</li>

    <li>a more standardized structure and representation of programs, independent of the personal taste and habits of different authors.</li>
  </ul>

  <h3>Flexibility-centric languages would emphasize ...</h3>

  <ul>
    <li>the utmost freedom of the programmer in which order to proceed, or where to do what, or which things to put together or to separate,</li>

    <li>&quot;expressiveness&quot;: a rich repertoire of specialized, very concise, perhaps adaptable expressive means for special situations,</li>

    <li>allowing also access to lower-level features;</li>

    <li>the dynamic nature of the language, for instance dynamic creation of new classes, fields, or methods at run time,</li>

    <li>extensibility of the language, macro and template support,</li>

    <li>run time checks; static checks only where possible in spite of the flexibility and dynamic nature of the language.</li>
  </ul>

  <h3>Clarity and flexibility certainly aren&#39;t completely incompatible, but ...</h3>

  <p>experience shows that most programming languages can be easily classified as putting more emphasis on &quot;freedom&quot; or more emphasis on &quot;discipline&quot;. Admittedly and understandably, most programmers would prefer freedom. But today a program is no longer a dialog between a single programmer and a computer. To an increasing degree programs are <em>joint</em> intellectual property of a <em>group</em> of programmers whose membership may fequently change.</p>

  <p>Therefore it is of increasing importance that a program can be easily understood not only by its author but also by other programmers having different preferences and habits. Consequently ...</p>

  <h3 class="c3"><span class="style1">Lava</span> is oriented towards the clarity goal ...</h3>

  <p>since we believe that comprehensibility, ease of maintenance and modification by different programmers, a clear and natural, more standardized structure and representation of programs in the small and in the large and comprehensive support by structure-oriented programming tools, static checks and early error reporting are those things that we need most urgently today.</p>

  <p>They should have priority over tricky, sophisticated, hard to understand, specialized or highly dynamic features, personal programming styles, and superficial simplicity/shortness of expressions whose actual effect is highly dependent on the respective static or even run time context and can be understood only after an arduous analysis.</p>

  <h3 class="c3">See also</h3>

  <p><strong><a href="IniChecks.htm">Complete static initialization checks</a></strong></p>

  <p><a href="OOPS-MIMM.htm">Object-Oriented Problem Separation</a></p>

  <p><a href="OOanalysis.htm">Using <em>Lava</em> for object-oriented analysis and design</a></p>
</body>
</html>
