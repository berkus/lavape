<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>The Lava interpreter</title>
  <link rel="STYLESHEET" type="text/css" href="LavaStyles.css" />
  <style type="text/css" xml:space="preserve">
/*<![CDATA[*/
  h2.c2 {text-align: center}
  b.c1 {font-style: italic; color: Red}
  /*]]>*/
      .style1
      {
          color: #FF0000;
          font-weight: bold;
      }
  </style>
</head>

<body>
  <h2 class="c2">The object-oriented <b class="c1">Lava</b> interpreter</h2>

  <p>The point-and-click operations of the <b class="c1">Lava</b> programmer (using <b class="c1">LavaPE</b>) operate directly on an internal tree-representation of the lava program (a kind of &quot;abstract syntax tree&quot;). Particularly the executable <b class="c1">Lava</b> constructs correspond to specific <b class="c1">C++</b> classes. The <b class="c1">C++</b> class of a <b class="c1">Lava</b> statement or expression construct comprises an &quot;Execute&quot; or &quot;Evaluate&quot; member function, respectively. These essentially make up the <b class="c1">Lava</b> interpreter (together with various functions of the <b class="c1">Lava</b> run time system, of course). Note that also the logical conjunctions (like &quot;;&quot; = &quot;and&quot;, &quot;or&quot;, &quot;not&quot;, &quot;if-then-else&quot;, &quot;switch&quot;, ...) and the quantifiers (&quot;declare&quot;, &quot;foreach&quot;, &quot;exists&quot;, &quot;select&quot;) are represented in this way and have specific &quot;Execute&quot; functions (or &quot;Evaluate&quot; for the &quot;select&quot; expression).</p>

  <p>So the <b class="c1">Lava</b> interpreter is not a separate piece of program of its own but is, in a sense, spread over the <b class="c1">C++</b> classes representing the various executable <b class="c1">Lava</b> constructs.</p>

  <p>The internal tree-representation of a <b class="c1">Lava</b> program is transformed into an ASN.1 encoding when the program is stored in a file. The interpreter reads this ASN.1 representation into main memory before execution, transforms it back into the original tree-representation and recursively checks the entire program for correctness and completeness. The check functions for the executable constructs are again member functions of the <b class="c1">C++</b> classes corresponding to the respective constructs. They are essentially the same check functions that are also applied after each point-and-click editing operation of the <b class="c1">Lava</b> programmer at programming time, but would typically compute additional information that is needed at execution time, for instance &quot;virtual function tables&quot; (VFT&#39;s), relative positions of functions within these VFT&#39;s, relative positions of local variables on the run time stack and of member objects within the containing object.</p>

  <h3>Advantages of the object-oriented <b class="c1">Lava</b> interpreter as compared with a VM or &quot;byte code&quot; interpreter:</h3>

  <ol>
    <li>The object-oriented interpreter of <b class="c1">Lava</b> operates on <i>whole 
        <span class="style1">Lava</span> constructs</i> whose interpretation is performed by small and efficient <b class="c1">C++</b> functions, whereas a byte code interpreter operates on the very low level of tiny, individual bytes. Hence an object-oriented interpreter can be expected to run significantly faster than a byte code interpreter.</li>

    <li>The development of an object-oriented interpreter is much easier than the development of a virtual machine.</li>

    <li>In particular, by <i>reinterpreting</i> a <b class="c1">Lava</b> program as a <b class="c1">C++</b> program in this way we can utilize many features of the <b class="c1">C++</b> run time system <i>directly</i> for <b class="c1">Lava</b>; for instance, <b class="c1">C++</b> exception handling to handle non-catchable <b class="c1">Lava</b> exceptions (&quot;fatal errors&quot;), <b class="c1">C++</b> threads (or rather the QThread class of Qt) to implement concurrent execution in <b class="c1">Lava</b>; even the <b class="c1">C++</b> run time stack can be used <i>directly</i> as <b class="c1">Lava</b> run time stack with the help of very few inline assembler statements. We need not reconstruct all these features from scratch on a byte code / virtual machine level.</li>

    <li>It is much easier to <i>adapt</i> an object-oriented interpreter to new or modified language constructs.</li>

    <li><i>Compilation</i> into byte code is not required.</li>

    <li>Delicate and error-prone <i>byte code verification</i> before execution is not required.</li>
  </ol>
</body>
</html>
